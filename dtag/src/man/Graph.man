.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "run::DTAG::Graph 3"
.TH run::DTAG::Graph 3 "2003-08-04" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "DTAG::Graph"
.IX Header "DTAG::Graph"
.Sh "\s-1NAME\s0"
.IX Subsection "NAME"
DTAG::Graph \- \s-1DTAG\s0 dependency graphs
.Sh "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
DTAG::Graph \- creating, manipulating and drawing dependency graphs
.Sh "\s-1METHODS\s0"
.IX Subsection "METHODS"
.ie n .IP "$graph\->abbr2var($abbr) = $var" 4
.el .IP "$graph\->abbr2var($abbr) = \f(CW$var\fR" 4
.IX Item "$graph->abbr2var($abbr) = $var"
Find variable name \f(CW$var\fR corresponding to variable name abbreviation
\&\f(CW$abbr\fR.
.ie n .IP "$graph\->boundaries($boundaries) = $boundaries" 4
.el .IP "$graph\->boundaries($boundaries) = \f(CW$boundaries\fR" 4
.IX Item "$graph->boundaries($boundaries) = $boundaries"
Get/set list of boundaries. ???
.ie n .IP "$graph\->child($node, $type\fR) = [$child1, \f(CW$child2, ...]" 4
.el .IP "$graph\->child($node, \f(CW$type\fR) = [$child1, \f(CW$child2\fR, ...]" 4
.IX Item "$graph->child($node, $type) = [$child1, $child2, ...]"
Return list of all child nodes of node \f(CW$node\fR which are connected to 
\&\f(CW$node\fR by an edge with type \f(CW$type\fR.
.ie n .IP "$graph\->child_edge($node, $type) = [$edge, ...]" 4
.el .IP "$graph\->child_edge($node, \f(CW$type\fR) = [$edge, ...]" 4
.IX Item "$graph->child_edge($node, $type) = [$edge, ...]"
Return all child edges of node \f(CW$node\fR whose edge type equals \f(CW$type\fR.
.IP "$graph\->\fIclear()\fR" 4
.IX Item "$graph->clear()"
Delete all nodes and edges from graph.
.ie n .IP "$graph\->ddominates($super, $node\fR) = \f(CW$boolean" 4
.el .IP "$graph\->ddominates($super, \f(CW$node\fR) = \f(CW$boolean\fR" 4
.IX Item "$graph->ddominates($super, $node) = $boolean"
Return true if \f(CW$super\fR dominates or equals \f(CW$node\fR in the deep tree.
.ie n .IP "$graph\->diffminus($edge) = $boolean" 4
.el .IP "$graph\->diffminus($edge) = \f(CW$boolean\fR" 4
.IX Item "$graph->diffminus($edge) = $boolean"
Return true if \f(CW$edge\fR is a diff-edge which does not exist in \f(CW$graph\fR,
otherwise return false. 
.ie n .IP "$graph\->diffplus($edge) = $boolean" 4
.el .IP "$graph\->diffplus($edge) = \f(CW$boolean\fR" 4
.IX Item "$graph->diffplus($edge) = $boolean"
Return true if \f(CW$edge\fR is a non-diff edge which does not exist in the
associated diff \f(CW$graph\fR, otherwise return false. 
.ie n .IP "$graph\->do_edges($action, @args)" 4
.el .IP "$graph\->do_edges($action, \f(CW@args\fR)" 4
.IX Item "$graph->do_edges($action, @args)"
Call the procedure &$action($e, \f(CW@args\fR) for each edge \f(CW$e\fR in the graph. 
.ie n .IP "$graph\->edge_add($edge) = $edge" 4
.el .IP "$graph\->edge_add($edge) = \f(CW$edge\fR" 4
.IX Item "$graph->edge_add($edge) = $edge"
Add edge \f(CW$edge\fR to \f(CW$graph\fR.
.ie n .IP "$graph\->edge_del($edge) = $edge" 4
.el .IP "$graph\->edge_del($edge) = \f(CW$edge\fR" 4
.IX Item "$graph->edge_del($edge) = $edge"
Remove edge \f(CW$edge\fR from \f(CW$graph\fR.
.ie n .IP "$graph\->etypes($etypes) = $etypes" 4
.el .IP "$graph\->etypes($etypes) = \f(CW$etypes\fR" 4
.IX Item "$graph->etypes($etypes) = $etypes"
Get/set edge type hash associated with graph.
.ie n .IP "$graph\->file($file) = $file" 4
.el .IP "$graph\->file($file) = \f(CW$file\fR" 4
.IX Item "$graph->file($file) = $file"
Get/set file associated with graph.
.ie n .IP "$graph\->format($var, $regexp)" 4
.el .IP "$graph\->format($var, \f(CW$regexp\fR)" 4
.IX Item "$graph->format($var, $regexp)"
Set variable formatting for variable \f(CW$var\fR to filtering by regular expression \f(CW$regexp\fR. 
.ie n .IP "$graph\->fpsfile($fpsfile) = $fpsfile" 4
.el .IP "$graph\->fpsfile($fpsfile) = \f(CW$fpsfile\fR" 4
.IX Item "$graph->fpsfile($fpsfile) = $fpsfile"
Get/set follow postscript file associated with graph.
.ie n .IP "$graph\->governor($node) = $gov" 4
.el .IP "$graph\->governor($node) = \f(CW$gov\fR" 4
.IX Item "$graph->governor($node) = $gov"
Return governor \f(CW$gov\fR for node \f(CW$node\fR.
.ie n .IP "$graph\->\fIgraph_id()\fR = $id" 4
.el .IP "$graph\->\fIgraph_id()\fR = \f(CW$id\fR" 4
.IX Item "$graph->graph_id() = $id"
Return graph \s-1ID\s0 associated with graph.
.ie n .IP "$graph\->input($input) = $input" 4
.el .IP "$graph\->input($input) = \f(CW$input\fR" 4
.IX Item "$graph->input($input) = $input"
Get/set input associated with graph.
.ie n .IP "$graph\->layout($default, $var\fR) = \f(CW$layout" 4
.el .IP "$graph\->layout($default, \f(CW$var\fR) = \f(CW$layout\fR" 4
.IX Item "$graph->layout($default, $var) = $layout"
Return layout value \f(CW$layout\fR for variable \f(CW$var\fR, retrieving the layout
value from \f(CW$default\fR if it isn't defined by \f(CW$graph\fR.
.ie n .IP "$self\->lexicon($lexicon) = $lexicon" 4
.el .IP "$self\->lexicon($lexicon) = \f(CW$lexicon\fR" 4
.IX Item "$self->lexicon($lexicon) = $lexicon"
Get/set lexicon associated with graph.
.ie n .IP "$self\->lexicon_stream($stream, $lexicon\fR) = \f(CW$lexicon" 4
.el .IP "$self\->lexicon_stream($stream, \f(CW$lexicon\fR) = \f(CW$lexicon\fR" 4
.IX Item "$self->lexicon_stream($stream, $lexicon) = $lexicon"
Get/set lexicon associated with stream \f(CW$stream\fR in graph, using
\&\f(CW$graph\fR\->\fIlexicon()\fR as the default.
.ie n .IP "$graph\->lookahead($lookahead) = $lookahead" 4
.el .IP "$graph\->lookahead($lookahead) = \f(CW$lookahead\fR" 4
.IX Item "$graph->lookahead($lookahead) = $lookahead"
Get/set lookahead associated with graph.
.ie n .IP "$graph\->lookup($time, $stream\fR) = \f(CW$lexemes" 4
.el .IP "$graph\->lookup($time, \f(CW$stream\fR) = \f(CW$lexemes\fR" 4
.IX Item "$graph->lookup($time, $stream) = $lexemes"
Return list of all lexemes starting at time \f(CW$time\fR in input stream
\&\f(CW$stream\fR.
.ie n .IP "$graph\->lsite($node) = $lsite" 4
.el .IP "$graph\->lsite($node) = \f(CW$lsite\fR" 4
.IX Item "$graph->lsite($node) = $lsite"
Return landing site for node \f(CW$node\fR.
.ie n .IP "$graph\->lsite_auto($node) = $lsite" 4
.el .IP "$graph\->lsite_auto($node) = \f(CW$lsite\fR" 4
.IX Item "$graph->lsite_auto($node) = $lsite"
Return auto-generated landing site for node \f(CW$node\fR (the lowest
dominating node in the deep tree which has \f(CW$node\fR in its continuous
surface yield).
.ie n .IP "$graph\->lsite_default($node) = $lsite" 4
.el .IP "$graph\->lsite_default($node) = \f(CW$lsite\fR" 4
.IX Item "$graph->lsite_default($node) = $lsite"
Return default landing site for node \f(CW$node\fR (defined as the parent
node with edge type \*(L"land\*(R", or, if no such node exists, the governor
of \f(CW$node\fR). 
.IP "$graph\->matches($interpreter)" 4
.IX Item "$graph->matches($interpreter)"
Return hash containing all nodes in \f(CW$graph\fR which the interpreter
\&\f(CW$interpreter\fR has marked as matches from a \*(L"find\*(R" query. 
.ie n .IP "max($a, $b\fR) = \f(CW$max" 4
.el .IP "max($a, \f(CW$b\fR) = \f(CW$max\fR" 4
.IX Item "max($a, $b) = $max"
Return the maximum of \f(CW$a\fR and \f(CW$b\fR.
.ie n .IP "min($a, $b\fR) = \f(CW$min" 4
.el .IP "min($a, \f(CW$b\fR) = \f(CW$min\fR" 4
.IX Item "min($a, $b) = $min"
Return the minimum of \f(CW$a\fR and \f(CW$b\fR.
.ie n .IP "$graph\->mtime($set) = $mtime" 4
.el .IP "$graph\->mtime($set) = \f(CW$mtime\fR" 4
.IX Item "$graph->mtime($set) = $mtime"
Get/set modification time of graph. If \f(CW$set\fR is defined, \f(CW$mtime\fR is set
to the current time.
.ie n .IP "Graph\->\fInew()\fR = $graph" 4
.el .IP "Graph\->\fInew()\fR = \f(CW$graph\fR" 4
.IX Item "Graph->new() = $graph"
Create new Graph object.
.ie n .IP "$graph\->next_lexeme($time) = $lexeme" 4
.el .IP "$graph\->next_lexeme($time) = \f(CW$lexeme\fR" 4
.IX Item "$graph->next_lexeme($time) = $lexeme"
Return first lexeme after time position \f(CW$time\fR.
.ie n .IP "$graph\->node($pos) = $node" 4
.el .IP "$graph\->node($pos) = \f(CW$node\fR" 4
.IX Item "$graph->node($pos) = $node"
Return node \f(CW$node\fR at node position \f(CW$pos\fR.
.ie n .IP "$graph\->node_add($pos, $node\fR) = \f(CW$node" 4
.el .IP "$graph\->node_add($pos, \f(CW$node\fR) = \f(CW$node\fR" 4
.IX Item "$graph->node_add($pos, $node) = $node"
Insert node \f(CW$node\fR at position \f(CW$pos\fR in graph.
.ie n .IP "$graph\->nodes($nodes) = $nodes" 4
.el .IP "$graph\->nodes($nodes) = \f(CW$nodes\fR" 4
.IX Item "$graph->nodes($nodes) = $nodes"
Get/set node list \f(CW$nodes\fR.
.ie n .IP "$graph\->parent($node, $etype\fR) = \f(CW$nodes" 4
.el .IP "$graph\->parent($node, \f(CW$etype\fR) = \f(CW$nodes\fR" 4
.IX Item "$graph->parent($node, $etype) = $nodes"
Return list \f(CW$nodes\fR of all parent nodes for node \f(CW$node\fR with edge type
\&\f(CW$etype\fR.
.ie n .IP "$graph\->parent_edge($node, $etype\fR) = \f(CW$edges" 4
.el .IP "$graph\->parent_edge($node, \f(CW$etype\fR) = \f(CW$edges\fR" 4
.IX Item "$graph->parent_edge($node, $etype) = $edges"
Return list \f(CW$edges\fR of all parent edges for node \f(CW$node\fR with edge type
\&\f(CW$etype\fR.
.ie n .IP "$graph\->parents($node) = [$governor, $lsite]" 4
.el .IP "$graph\->parents($node) = [$governor, \f(CW$lsite\fR]" 4
.IX Item "$graph->parents($node) = [$governor, $lsite]"
Return governor and landing site for node \f(CW$node\fR.
.ie n .IP "$graph\->parse($parse) = $parse" 4
.el .IP "$graph\->parse($parse) = \f(CW$parse\fR" 4
.IX Item "$graph->parse($parse) = $parse"
Get/set parse object associated with graph.
.ie n .IP "$graph\->position($pos) = $pos" 4
.el .IP "$graph\->position($pos) = \f(CW$pos\fR" 4
.IX Item "$graph->position($pos) = $pos"
Get/set position of graph. ???
.ie n .IP "$graph\->\fIpostscript()\fR = $postscript" 4
.el .IP "$graph\->\fIpostscript()\fR = \f(CW$postscript\fR" 4
.IX Item "$graph->postscript() = $postscript"
Return PostScript representation \f(CW$postscript\fR for graph.
.ie n .IP "$graph\->\fIprint()\fR = $string" 4
.el .IP "$graph\->\fIprint()\fR = \f(CW$string\fR" 4
.IX Item "$graph->print() = $string"
Return simple string representation for graph (used for debugging
only).
.ie n .IP "$graph\->psfile($psfile) = $psfile" 4
.el .IP "$graph\->psfile($psfile) = \f(CW$psfile\fR" 4
.IX Item "$graph->psfile($psfile) = $psfile"
Get/set PostScript file associated with graph.
.ie n .IP "$graph\->psstyle($default, $context\fR, \f(CW$styles\fR) = \f(CW$ps" 4
.el .IP "$graph\->psstyle($default, \f(CW$context\fR, \f(CW$styles\fR) = \f(CW$ps\fR" 4
.IX Item "$graph->psstyle($default, $context, $styles) = $ps"
Return PostScript string \f(CW$ps\fR associated with style list \f(CW$styles\fR, given
style context \f(CW$context\fR and object \f(CW$default\fR defining default style
values. 
.ie n .IP "$graph\->reformat($interpreter, $var\fR, \f(CW$value\fR) = \f(CW$filtered" 4
.el .IP "$graph\->reformat($interpreter, \f(CW$var\fR, \f(CW$value\fR) = \f(CW$filtered\fR" 4
.IX Item "$graph->reformat($interpreter, $var, $value) = $filtered"
Return filtered value \f(CW$filtered\fR for variable \f(CW$var\fR with value \f(CW$value\fR,
using \f(CW$interpreter\fR to provide default filters. 
.IP "$graph\->\fIrelations()\fR" 4
.IX Item "$graph->relations()"
Extract list with all relations in graph. ???
.ie n .IP "$graph\->sdominates($lsite, $node\fR) = \f(CW$boolean" 4
.el .IP "$graph\->sdominates($lsite, \f(CW$node\fR) = \f(CW$boolean\fR" 4
.IX Item "$graph->sdominates($lsite, $node) = $boolean"
Return true if \f(CW$lsite\fR dominates \f(CW$node\fR in the surface tree, and false
otherwise.
.ie n .IP "$graph\->\fIsize()\fR = $size" 4
.el .IP "$graph\->\fIsize()\fR = \f(CW$size\fR" 4
.IX Item "$graph->size() = $size"
Return the number of nodes in the graph.
.ie n .IP "$graph\->streams($time1, $time2\fR) = \f(CW$streams" 4
.el .IP "$graph\->streams($time1, \f(CW$time2\fR) = \f(CW$streams\fR" 4
.IX Item "$graph->streams($time1, $time2) = $streams"
Return a list of stream identifiers for all streams that are active
between times \f(CW$time1\fR and \f(CW$time2\fR (which default to the beginning and
end of the graph, if unspecified).
.ie n .IP "$graph\->style($default, $name\fR) = \f(CW$style" 4
.el .IP "$graph\->style($default, \f(CW$name\fR) = \f(CW$style\fR" 4
.IX Item "$graph->style($default, $name) = $style"
Return style \f(CW$style\fR with style name \f(CW$name\fR, using \f(CW$default\fR to find the
default values of styles. 
.ie n .IP "$graph\->text($separator, $maxlen\fR) = \f(CW$text" 4
.el .IP "$graph\->text($separator, \f(CW$maxlen\fR) = \f(CW$text\fR" 4
.IX Item "$graph->text($separator, $maxlen) = $text"
Return the first \f(CW$maxlen\fR characters of text in the graph, inserting
\&\f(CW$separator\fR between the text of individual nodes. \f(CW$maxlen\fR defaults to
the length of the entire graph, and \f(CW$separator\fR defaults to "".
.ie n .IP "$graph\->time0($node) = $time0" 4
.el .IP "$graph\->time0($node) = \f(CW$time0\fR" 4
.IX Item "$graph->time0($node) = $time0"
Return starting time of node \f(CW$node\fR.
.ie n .IP "$graph\->time1($node) = $time1" 4
.el .IP "$graph\->time1($node) = \f(CW$time1\fR" 4
.IX Item "$graph->time1($node) = $time1"
Return ending time of node \f(CW$node\fR.
.ie n .IP "$graph\->var($var, $value\fR) = \f(CW$value" 4
.el .IP "$graph\->var($var, \f(CW$value\fR) = \f(CW$value\fR" 4
.IX Item "$graph->var($var, $value) = $value"
Get/set value \f(CW$value\fR for variable \f(CW$var\fR.
.ie n .IP "$graph\->vars($vars) = $vars" 4
.el .IP "$graph\->vars($vars) = \f(CW$vars\fR" 4
.IX Item "$graph->vars($vars) = $vars"
Get/set list \f(CW$vars\fR of user-defined variable names in graph.
.ie n .IP "$graph\->yield_simplify(@intervals) = @newintervals" 4
.el .IP "$graph\->yield_simplify(@intervals) = \f(CW@newintervals\fR" 4
.IX Item "$graph->yield_simplify(@intervals) = @newintervals"
Compute simplified set of intervals from \f(CW@intervals\fR = ([$start1,
\&\f(CW$stop1\fR], ...), and return in \f(CW@newintervals\fR.
.ie n .IP "$graph\->yields($node) = $yields" 4
.el .IP "$graph\->yields($node) = \f(CW$yields\fR" 4
.IX Item "$graph->yields($node) = $yields"
Compute yields hash \f(CW$yields\fR containing the yield of node \f(CW$node\fR and the
yield of all other nodes in the yield of \f(CW$node\fR. 
.SH "Edge"
.IX Header "Edge"
.Sh "\s-1NAME\s0"
.IX Subsection "NAME"
Edge \- edge in dependency graph
.Sh "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
Edge \- edge in dependency graph.
.Sh "\s-1METHODS\s0"
.IX Subsection "METHODS"
.RS 4
.ie n .IP "$edge\->\fIclone()\fR = $clone" 4
.el .IP "$edge\->\fIclone()\fR = \f(CW$clone\fR" 4
.IX Item "$edge->clone() = $clone"
Return clone \f(CW$clone\fR of edge \f(CW$edge\fR.
.ie n .IP "$edge\->cost($cost) = $cost" 4
.el .IP "$edge\->cost($cost) = \f(CW$cost\fR" 4
.IX Item "$edge->cost($cost) = $cost"
Get/set edge cost.
.ie n .IP "$edge\->eq($edge2) = $boolean" 4
.el .IP "$edge\->eq($edge2) = \f(CW$boolean\fR" 4
.IX Item "$edge->eq($edge2) = $boolean"
Test whether \f(CW$edge\fR and \f(CW$edge2\fR represent the same edge.
.ie n .IP "$edge\->in($in) = $in" 4
.el .IP "$edge\->in($in) = \f(CW$in\fR" 4
.IX Item "$edge->in($in) = $in"
Get/set in-node \f(CW$in\fR of edge. 
.ie n .IP "$edge\->match($typedef) = $boolean" 4
.el .IP "$edge\->match($typedef) = \f(CW$boolean\fR" 4
.IX Item "$edge->match($typedef) = $boolean"
Test whether \f(CW$edge\fR matches type definition \f(CW$typedef\fR, which must be a
regular expression or an atomic name. 
.ie n .IP "Edge\->\fInew()\fR = $edge" 4
.el .IP "Edge\->\fInew()\fR = \f(CW$edge\fR" 4
.IX Item "Edge->new() = $edge"
Create new edge \f(CW$edge\fR.
.ie n .IP "$edge\->out($out) = $out" 4
.el .IP "$edge\->out($out) = \f(CW$out\fR" 4
.IX Item "$edge->out($out) = $out"
Get/set out-node for edge.
.ie n .IP "$edge\->\fIprint()\fR = $string" 4
.el .IP "$edge\->\fIprint()\fR = \f(CW$string\fR" 4
.IX Item "$edge->print() = $string"
Return string representation of edge (used for debugging only).
.ie n .IP "$edge\->type($type) = $type" 4
.el .IP "$edge\->type($type) = \f(CW$type\fR" 4
.IX Item "$edge->type($type) = $type"
Get/set edge type.
.ie n .IP "$edge\->var($var, $value\fR) = \f(CW$value" 4
.el .IP "$edge\->var($var, \f(CW$value\fR) = \f(CW$value\fR" 4
.IX Item "$edge->var($var, $value) = $value"
Get/set value \f(CW$value\fR for variable \f(CW$var\fR in edge.
.ie n .IP "$edge\->vars($vars) = $vars" 4
.el .IP "$edge\->vars($vars) = \f(CW$vars\fR" 4
.IX Item "$edge->vars($vars) = $vars"
Get/set variable string for edge, used for storing variable-value
pairs. 
.SH "Node"
.IX Header "Node"
.Sh "\s-1NAME\s0"
.IX Subsection "NAME"
Node \- Node in DTAG::Graph
.Sh "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
Node \- node in dependency graph
.Sh "\s-1METHODS\s0"
.IX Subsection "METHODS"
.RS 4
.ie n .IP "$node\->active($active) = $active" 4
.el .IP "$node\->active($active) = \f(CW$active\fR" 4
.IX Item "$node->active($active) = $active"
Get/set list \f(CW$active\fR of active lexemes associated with node \f(CW$node\fR. 
.ie n .IP "$node\->comment($comment) = $comment" 4
.el .IP "$node\->comment($comment) = \f(CW$comment\fR" 4
.IX Item "$node->comment($comment) = $comment"
Get/set comment status of node: 1 = comment, 0 = not comment.
.ie n .IP "$node\->cost($cost) = $cost" 4
.el .IP "$node\->cost($cost) = \f(CW$cost\fR" 4
.IX Item "$node->cost($cost) = $cost"
Get/set cost associated with node.
.ie n .IP "dumpstr($object) = $string" 4
.el .IP "dumpstr($object) = \f(CW$string\fR" 4
.IX Item "dumpstr($object) = $string"
Return string representation of object.
.ie n .IP "$node\->extracted($extracted) = $extracted" 4
.el .IP "$node\->extracted($extracted) = \f(CW$extracted\fR" 4
.IX Item "$node->extracted($extracted) = $extracted"
Get/set list of extractions though \f(CW$node\fR.
.ie n .IP "$node\->in($in) = $in" 4
.el .IP "$node\->in($in) = \f(CW$in\fR" 4
.IX Item "$node->in($in) = $in"
Get/set list \f(CW$in\fR of in-edges for node \f(CW$node\fR.
.ie n .IP "$node\->input($input) = $input" 4
.el .IP "$node\->input($input) = \f(CW$input\fR" 4
.IX Item "$node->input($input) = $input"
Get/set node input.
.ie n .IP "$node\->layout($layout) = $layout" 4
.el .IP "$node\->layout($layout) = \f(CW$layout\fR" 4
.IX Item "$node->layout($layout) = $layout"
Get/set node layout.
.ie n .IP "$node\->lexemes($lexemes) = $lexemes" 4
.el .IP "$node\->lexemes($lexemes) = \f(CW$lexemes\fR" 4
.IX Item "$node->lexemes($lexemes) = $lexemes"
Get/set list \f(CW$lexemes\fR of lexemes associated with node \f(CW$node\fR.
.ie n .IP "Node\->\fInew()\fR = $node" 4
.el .IP "Node\->\fInew()\fR = \f(CW$node\fR" 4
.IX Item "Node->new() = $node"
Create new node.
.ie n .IP "$node\->out($out) = $out" 4
.el .IP "$node\->out($out) = \f(CW$out\fR" 4
.IX Item "$node->out($out) = $out"
Get/set list \f(CW$out\fR of out-edges at node \f(CW$node\fR.
.ie n .IP "$node\->position($pos) = $pos" 4
.el .IP "$node\->position($pos) = \f(CW$pos\fR" 4
.IX Item "$node->position($pos) = $pos"
Get/set node position.
.ie n .IP "$node\->\fIprint()\fR = $string" 4
.el .IP "$node\->\fIprint()\fR = \f(CW$string\fR" 4
.IX Item "$node->print() = $string"
Return string representation of \f(CW$node\fR (used for debugging only).
.ie n .IP "$node\->relpos($offset, $pos\fR) = \f(CW$relpos" 4
.el .IP "$node\->relpos($offset, \f(CW$pos\fR) = \f(CW$relpos\fR" 4
.IX Item "$node->relpos($offset, $pos) = $relpos"
Return relative position \f(CW$relpos\fR of node with position \f(CW$pos\fR and offset
\&\f(CW$offset\fR.
.ie n .IP "$node\->segment($segment) = $segment" 4
.el .IP "$node\->segment($segment) = \f(CW$segment\fR" 4
.IX Item "$node->segment($segment) = $segment"
Get/set list of segments associated with node.
.ie n .IP "$node\->selected($selected) = $selected" 4
.el .IP "$node\->selected($selected) = \f(CW$selected\fR" 4
.IX Item "$node->selected($selected) = $selected"
Get/set selected lexeme at node. 
.ie n .IP "$node\->stream($stream) = $stream" 4
.el .IP "$node\->stream($stream) = \f(CW$stream\fR" 4
.IX Item "$node->stream($stream) = $stream"
Get/set stream associated with node (default stream = 0).
.ie n .IP "$node\->time0($time0) = $time0" 4
.el .IP "$node\->time0($time0) = \f(CW$time0\fR" 4
.IX Item "$node->time0($time0) = $time0"
Get/set starting time at node.
.ie n .IP "$node\->time1($time1) = $time1" 4
.el .IP "$node\->time1($time1) = \f(CW$time1\fR" 4
.IX Item "$node->time1($time1) = $time1"
Get/set ending time at node \f(CW$node\fR.
.ie n .IP "$node\->use_color($color) = $color" 4
.el .IP "$node\->use_color($color) = \f(CW$color\fR" 4
.IX Item "$node->use_color($color) = $color"
Get/set color used at \f(CW$node\fR. ???
.ie n .IP "$node\->var($var, $value\fR) = \f(CW$value" 4
.el .IP "$node\->var($var, \f(CW$value\fR) = \f(CW$value\fR" 4
.IX Item "$node->var($var, $value) = $value"
Get/set value \f(CW$value\fR associated with variable \f(CW$var\fR at \f(CW$node\fR.
.ie n .IP "$node\->varstr($var, $perlexpr\fR) = \f(CW$perlexpr" 4
.el .IP "$node\->varstr($var, \f(CW$perlexpr\fR) = \f(CW$perlexpr\fR" 4
.IX Item "$node->varstr($var, $perlexpr) = $perlexpr"
Get/set value for variable \f(CW$var\fR, using a string \f(CW$perlexpr\fR evaluated
as a Perl expression.
.ie n .IP "$node\->xml($graph, $displace\fR) = \f(CW$xml" 4
.el .IP "$node\->xml($graph, \f(CW$displace\fR) = \f(CW$xml\fR" 4
.IX Item "$node->xml($graph, $displace) = $xml"
Return xml-representation \f(CW$xml\fR of node \f(CW$node\fR within graph \f(CW$graph\fR,
where \f(CW$displace\fR is the position of the node in the file. 
