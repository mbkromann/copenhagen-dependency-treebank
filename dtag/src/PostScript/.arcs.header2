100 dict begin /llx 20 def /lly 20 def /urx 500 def /ury 810 def /titley 820 def /clipdx2 10 def /LW 1 def /X 2 def /Y 0 def /dO 5 def /dAs 1 def /dA 10 def /dAW 2.5 def /dAH 6 def /dT 15 def /dB 18 def /dT0 12 def /dB0 8 def /dW 0 def /dWr 0.5 def /dH 10 def /dL 20 def /center false def /dEA 6 def /dET0 3 def /dEB0 -7 def /dEsw 1 def /dEow 0 def /dElw 2.5 def /dElwa 0.3 def /Emaxht 0 def /Emaxhb 0 def /EmaxhtMax 5 def /EmaxhbMax 5 def /dEah 4 def /dEaw 0.3 def /dEmaxw 200 def /strings 1 def /framegray -1 def /bggray -1 def /smallfont 7 def /textfont 10 def /charstroke smallfont 0.4 mul def /dy_lbl smallfont -0.3 mul def /nextw 0 def /nexte 0 def LW setlinewidth /xdef {exch def} def /max {dup 3 -1 roll dup 3 -1 roll lt {pop} {exch pop} ifelse} def /min {dup 3 -1 roll dup 3 -1 roll gt {pop} {exch pop} ifelse} def /ISOfont {findfont dup length dict begin {1 index /FID ne {def} {pop pop} ifelse} forall /Encoding ISOLatin1Encoding def currentdict end definefont pop} def /setfontfamily {/fontfamily xdef} def /setfontsize {/fontsize xdef} def /setfontstyle {/fontstyle xdef} def /setarrowtype {/arrowtype xdef} def /font 7 string def /fontext 4 string def /setupfont {font 0 fontfamily 0 get putinterval font 3 fontstyle 1 add 1000 mul fontsize cvi add fontext cvs putinterval currentdict font cvn known not {currentdict font cvn fontfamily fontstyle 1 add get findfont fontsize scalefont put} if font cvn cvx exec setfont} def /createfontfamily {5 array astore exch {dup dup 1 get /Palatino-Roman-isolatin1 dup 3 1 roll exch ISOfont 1 exch put dup dup 2 get /Palatino-Bold-isolatin1 dup 3 1 roll exch ISOfont 2 exch put dup dup 3 get /Palatino-Italic-isolatin1 dup 3 1 roll exch ISOfont 3 exch put dup dup 4 get /Palatino-BoldItalic-isolatin1 dup 3 1 roll exch ISOfont 4 exch put} if} def /qsort {1 index length 0 exch qsortx pop} def /qsortx {2 copy 2 sub gt {pop pop} {findpivot dup -1 eq {pop pop pop} {4 index exch get 3 1 roll 2 copy 7 2 roll 1 sub {exch {dup 5 index exch get 3 index 5 index exec -1 eq {1 add} {exit} ifelse} loop exch {dup 5 index exch get 3 index 5 index exec -1 gt {1 sub} {exit} ifelse} loop 2 copy gt {exit} if 2 copy 6 index 3 1 roll switch} loop 3 -1 roll pop pop 5 -1 roll exch dup 6 1 roll qsortx 4 2 roll qsortx} ifelse} ifelse} def /findpivot {2 copy add 1 sub 2 idiv 4 index 1 index get 1 index 1 1 index 5 index add 6 index sub 1 sub {dup 4 index ge {4 index add 3 index sub} if dup 7 index exch get 2 index 7 index exec dup 0 ne {1 eq {3 -1 roll pop -1 3 1 roll exit} {pop -1 3 1 roll exch exit} ifelse} {pop pop} ifelse} for 2 index -1 eq {3 1 roll pop pop} {pop pop -1} ifelse} def /switch {2 index 2 index get 3 index 2 index get 4 index exch 6 1 roll 3 1 roll put 3 -1 roll put} def /intcmp {2 copy lt {pop pop -1} {eq {0} {1} ifelse} ifelse} def /format {pop gsave /oldfontstyle fontstyle def /oldfontsize fontsize def /oldfontfamily fontfamily def /oldarrowtype arrowtype def /olddAs dAs def exch dup 0 ge 1 index formats length le and {dup 0 eq {pop} {formats exch 1 sub get exec} ifelse} {pop} ifelse exec grestore /dAs olddAs def oldarrowtype setarrowtype fontstyle oldfontstyle ne fontsize oldfontsize ne or fontfamily oldfontfamily ne or {oldfontfamily setfontfamily oldfontsize setfontsize oldfontstyle setfontstyle setupfont} if} def /arrowlbl {5 1 roll dA mul 2 index add 5 -1 roll 4 index 3 index add 2 div 2 index 5 index sub 0.75 mul 5 index add moveto dup stringwidth pop -2 div dy_lbl rmoveto 4 index 3 index sub abs dO 1.05 mul lt {dO neg 1.5 mul 0 rmoveto} if 0 currentlinewidth eq {pop} {gsave dup 0 setlinecap [] 0 setdash true charpath charstroke setlinewidth 1 setgray stroke grestore show} ifelse pop pop pop pop} def /arrow {3 index 2 index sub abs dO 1.05 mul lt {dA mul 0.75 mul 2 index add 4 -1 roll 15 sub 4 1 roll matrix currentmatrix 4 index 3 index add 2 div 4 index translate 4 index 3 index sub 2 div abs 4 index 3 index sub scale newpath 0 0 1 180 360 arc setmatrix currentlinewidth 0 eq {newpath} {stroke} ifelse} {dA mul 2 index add 4 copy exch 2 copy 5 index 5 1 roll 5 index 8 -2 roll moveto curveto currentlinewidth 0 eq {newpath} {stroke} ifelse} ifelse 2 index gt {-1} {1} ifelse dAH dAs mul mul 3 1 roll exch moveto dAW dAs mul 0 rmoveto dAW dAs mul -2 mul 0 rlineto dAW dAs mul exch rlineto pop closepath currentlinewidth 0 eq {newpath} {fill} ifelse} def /word {strings 2 mul 1 add array strings -1 1 {2 index type /integertype eq {4 2 roll} {3 -1 roll 0} ifelse 3 index 3 index 2 mul 3 -1 roll put 2 index 2 index 2 mul 1 sub 3 -1 roll put pop} for 0 1 1 strings {2 index exch 2 mul dup 1 sub 2 index exch get 3 1 roll get {stringwidth} 0 format pop max} for widths nextw 3 -1 roll put dup 0 0 put currentdict /words known {words nextw 3 -1 roll put} if /nextw nextw 1 add def} def /newedge {dup type /stringtype eq {0 0} {1 index type /stringtype eq {dup} if} ifelse 5 2 roll 3 1 roll 2 copy gt {exch neg} if 3 -1 roll 0 1 7 -2 roll center 8 array astore} def /edget {newedge currentdict /edges known {edges nexte 3 -1 roll put} if /nexte nexte 1 add def} def /edgeb {newedge dup 4 -1 put currentdict /edges known {edges nexte 3 -1 roll put} if /nexte nexte 1 add def} def /eedget {/barstyle xdef /fixpass1 xdef /fixpass2 xdef /fixwidth1 xdef /fixwidth2 xdef newedge fixedge currentdict /edges known {edges nexte 3 -1 roll put} if /nexte nexte 1 add def} def /eedgeb {/barstyle xdef /fixpass1 xdef /fixpass2 xdef /fixwidth1 xdef /fixwidth2 xdef newedge dup 4 -1 put fixedge currentdict /edges known {edges nexte 3 -1 roll put} if /nexte nexte 1 add def} def /fixedge {[ exch aload pop fixwidth2 4 index 0 lt {neg} if fixwidth1 fixpass2 fixpass1 barstyle] dup 4 0 put} def /xcenter {dup words exch get 0 get exch 1 add dup words length eq {pop X} {words exch get 0 get} ifelse add 2 div} def /edge_heights {[ exch 0 0 0 edge_heights0 {pop} repeat pop pop pop pop} def /edge_heights0 {{edge_heights1 {true} {edge_heights2} ifelse {true} {edge_heights3} ifelse {true} {edge_heights4} ifelse not {exit} if} loop} def /edge_heights1 {dup 2 lt {false} {4 index length 3 eq {true} {4 index 3 get -1 eq} ifelse} ifelse {5 -1 roll dup 1 get exch 2 get 6 index dup dup 2 get 4 -1 roll max 2 exch put 1 3 -1 roll put 1 sub true} {false} ifelse} def /edge_heights2 {dup 0 gt {4 index length 3 gt {4 index 3 get -1 ne {4 index dup dup 1 get exch 3 get edges exch get 1 get abs eq {dup dup 2 get 1 add 2 exch dup 4 1 roll put 1 index 3 get edges exch get 3 3 -1 roll 7 index exec put mark exch dup aload pop counttomark 4 sub -1 roll pop -1 counttomark -1 roll astore pop pop true} {pop false} ifelse} {false} ifelse} {false} ifelse} {false} ifelse} def /edge_heights3 {dup 1 gt {5 index 5 index dup 1 get exch 2 get 3 -1 roll 1 get 2 index ne {7 index dup 1 5 -1 roll put dup 2 get 3 -1 roll max 2 exch put 5 -1 roll 1 index 4 add 1 roll 1 sub edge_heights0 1 add dup 4 add -1 roll 5 1 roll true} {pop pop false} ifelse} {false} ifelse} def /edge_heights4 {counttomark 1 index 4 add eq {2 index words length lt {mark 3 index dup 0 7 index 6 index {dup edges length ge {exch pop exit} if dup edges exch get dup 0 get 6 index eq {4 get 2 index exec 0 gt{dup 6 1 roll} if 1 add} {pop exch pop exit} ifelse} loop counttomark 1 add 1 roll counttomark 3 roll ] 6 1 roll 3 1 roll 1 add exch pop 3 -1 roll 1 add 3 1 roll true} {false} ifelse} {false} ifelse} def /edge_displace {-1 -1 0 0 0 {2 index words length ge {pop pop pop pop pop exit} if 5 -2 roll pop pop -1 -1 5 2 roll 1 index edges 0 3 -1 roll update_super dup maxedges 1 3 -1 roll update_super exch edges 0 3 -1 roll displace exch maxedges 1 3 -1 roll displace 3 -1 roll 1 add 3 1 roll} loop} def /displace {{dup 3 index length ge {3 1 roll pop pop exit} if 2 index 1 index get dup 3 index get abs 6 index gt {pop 3 1 roll pop pop exit} if dup ioword 7 index eq {1 index 3 get 0 gt {8 index} {7 index} ifelse dup -1 eq {pop pop 4 0 put} {7 index -1 2 index 2 index gt {neg exch 3 1 roll} if 4 1 roll 2 index gt 3 1 roll gt and not {neg} if 4 exch put} ifelse} {pop pop} ifelse 1 add} loop} def /update_super {{dup 3 index length ge {pop pop pop exit} if 2 index 1 index get dup 3 index get 7 index gt {pop pop pop pop exit} if dup ioword exch 8 index eq {exch 3 get 0 gt {9 -1 roll pop 8 1 roll} {8 -1 roll pop 7 1 roll} ifelse} {pop pop} ifelse 1 add} loop} def /ioword {dup 0 get exch 1 get dup 0 lt {abs exch} {abs} ifelse} def /split_lines {split_words split_edges split_pages} def /split_words {/lines [ urx llx sub 0 0 1 {1 index words length ge {pop pop pop pop exit} if [2 index 0 5 index 0 0 0 0 0] 5 1 roll {dup xpos 1 index words length ge {dup} {1 index 1 add xpos} ifelse 4 index sub 5 index gt 2 index newline or 2 index words length ge or {exch 4 2 roll pop pop dup 1 add exit} if pop 1 add} loop} loop [words length edges length X 0 0 0 0 0] ] def} def /split_edges {0 [] 0 1 lines length 2 sub {dup 1 add lines exch get 0 get exch lines exch get 0 0 2 index [ 8 2 roll 4 index {dup edges exch get 1 get abs 5 index ge {dup 8 1 roll} if edges exch get 3 get dup 4 -1 roll min 3 1 roll max} forall {5 index edges length ge {exit} if 5 index edges exch get 0 get 4 index ge {exit} if 5 index edges exch get dup 1 get abs 5 index ge {6 index 7 1 roll} if 3 get dup 4 -1 roll min 3 1 roll max 6 -1 roll 1 add 6 1 roll} loop 2 index 4 3 -1 roll put 1 index 5 3 -1 roll abs put 3 1 roll pop pop 1 2 index put counttomark 1 add 1 roll ] 2 index 6 2 index put 3 -1 roll 1 3 index put} for pop pop} def /split_pages {0 ury lly sub 0 0 1 lines length 2 sub {lines exch get dup line_height 3 index 3 index 2 index add lt {3 -1 roll 5 -1 roll add 4 1 roll 0 3 1 roll} if 1 index 7 6 index put exch 3 3 index put add dL add} for pop pop pop} def /line_height {dup 4 get exch 5 get add dA mul strings dH mul add dB add dT add} def /xpos {dup words length ge {pop X} {words exch get 0 get} ifelse} def /newline {1 sub dup words length ge 1 index 0 lt or {pop false} {words exch get 1 get (\n) eq} ifelse} def /layout_word {1 index 4 index 4 get dA mul sub dT sub 1 index xcenter 4 index add exch xwords nword 3 index put ywords nword 2 index 8 index 7 get sub put /nword nword 1 add def} def /print_word {layout_word 3 -1 roll words exch get 1 1 strings {3 -1 roll dH sub 3 1 roll 2 copy 2 mul get 3 1 roll 1 index exch 2 mul 1 sub get dup 3 index {stringwidth} 0 format pop 2 div neg 5 index add 4 index moveto 3 -1 roll {show} 0 format} for pop pop pop} def /print_edge_cross {dup edges exch get length 8 gt {edges exch get print_fixation_edge} {print_edge} ifelse} def /print_edge {edges exch get dup length 8 gt {print_fixation_edge} {1 index 1 index 7 get 6 1 roll 4 index 4 get dA mul sub 1 index 3 get 0 ge {dup dT0 sub} {dT sub strings dH mul sub dB sub dup dB0 add} ifelse 2 index ioword xcenter 6 index add exch xcenter 6 index add dup 4 -1 roll moveto 7 index not {3 index 2 get dup 5 index 5 get {stringwidth} 0 format pop -2 div 0 rmoveto 4 index 5 get {currentlinewidth 0 eq {pop} {show} ifelse} 1 format} if exch 3 index 4 get dO mul add 3 1 roll 3 index 3 get 4 copy 8 index 6 get {arrow} 2 format 8 index {4 index 2 get 5 index 5 get {arrowlbl} 1 format} {pop pop pop pop} ifelse pop 4 -1 roll pop} ifelse} def /xylword {7 get exch xyword 3 -1 roll add} def /print_fixation_edge {dup ioword words 2 index get 0 get words 2 index get 0 get sub abs dEmaxw lt {3 index 6 index 4 get dA mul sub dT sub dup 3 index xcenter 7 index add 3 index xcenter 8 index add 4 1 roll exch 6 -2 roll pop pop} {5 index xylword 3 -1 roll 6 index xylword} ifelse 4 index 10 get dEA mul 5 index 11 get dEA mul 6 index 8 get 0 gt {dET0 add exch dET0 add exch} {neg fixbotadjust dEB0 add exch neg fixbotadjust dEB0 add exch} ifelse 5 -1 roll add 4 1 roll add 4 index 8 get abs dEsw mul dEow add 5 index 9 get dEsw mul dEow add 4 1 roll 3 copy 9 index draw_fixation_bar 6 index 10 index 1 index 6 get {draw_fixation_edge} 2 format pop} def /draw_fixation_bar {gsave 4 2 roll 0 sub moveto gsave exch dup 2 div neg 0 rmoveto 0 rlineto currentlinewidth dElw mul setlinewidth dup 5 get {stroke} 2 format grestore 0 -2 rmoveto dup 2 get exch 12 get {cshow} 2 format grestore} def /draw_fixation_bar {gsave 4 2 roll 0 sub moveto exch dup 2 div neg 0 rmoveto 0 rlineto currentlinewidth dElw mul setlinewidth dup 5 get {stroke} 2 format 5 -2 rmoveto dup 2 get exch 12 get {cshow} 2 format grestore} def /cshow {dup stringwidth pop 2 div neg 0 rmoveto show} def /cshowbgfill {dup stringwidth pop 2 div neg 0 rmoveto gsave dup 0 setlinecap [] 0 setdash true charpath charstroke setlinewidth 1 setgray stroke grestore show} def /draw_fixation_edge {exch 8 2 roll 5 index 3 index eq 5 index 3 index eq and {pop pop pop pop pop pop pop pop} {2 div 3 -1 roll exch sub exch 5 2 roll 2 div 3 -1 roll add exch gsave dup 3 index sub abs 50 lt 2 index 5 index ne and {2 copy moveto 3 -1 roll sub neg 3 1 roll sub exch dEah 3 index 8 get 0 le {neg} if 3 1 roll 2 copy dEaw mul exch dEaw mul exch 3 index 2 div 3 index 2 div 6 index add 0 0 3 index 6 index sub 3 index 6 index sub 5 index 5 index rcurveto 6 index 2 mul sub 2 copy rcurveto pop pop pop} {moveto lineto} ifelse stroke pop pop grestore} ifelse} def /sort_edges {edges {2 copy 0 get exch 0 get exch intcmp dup 0 ne {3 1 roll pop pop} {pop 1 get abs exch 1 get abs exch intcmp} ifelse} qsort pop /maxedges edges edges length array copy def maxedges {2 copy 1 get abs exch 1 get abs exch intcmp dup 0 ne {3 1 roll pop pop} {pop 0 get exch 0 get exch intcmp} ifelse} qsort pop} def /center_edge_label {words length array words length array 0 1 words length 1 sub {dup 3 index exch 0 put 1 index exch 0 put} for smallfont setfontsize setupfont edges {dup 4 1 roll edgein {dup 3 index exch get 1 add 3 index 3 1 roll put} {dup 2 index exch get 4 index length 10 lt {1 add} if 2 index 3 1 roll put} ifelse 3 -1 roll pop} forall edges {dup edgein {3 index exch get 1 gt {dup 7 true put} if} {2 index exch get 1 gt {dup 7 true put} if} ifelse pop} forall edges {dup edgein pop 1 index 7 get not {exch dup 2 get exch 5 get {stringwidth} 0 format pop widths dup 3 index get 3 -1 roll max exch 3 1 roll put} {pop pop} ifelse} forall pop pop /X 0 def widths words 0 1 words length 1 sub {dup 3 index exch get exch 2 index exch get dup 0 get 3 -1 roll max 1 index 0 X put exch 2 get {fontsize} 0 format dWr mul /dWline xdef X add dWline add /X exch def} for /X X dWline sub def pop pop} def /edgein {dup 1 get dup 0 lt {abs} {pop dup 0 get} ifelse exch 4 get 0 gt} def /layout_arcs {sort_edges center_edge_label {} edge_heights {neg} edge_heights 0 1 edges length 1 sub {edges exch get 4 0 put} for edge_displace split_lines} def /layout_line {dup lines exch get dup line_height 1 index 2 get dup 4 index 1 add lines exch get 2 get exch sub 3 1 roll llx exch sub 3 index 3 get ury exch sub 4 2 roll pop pop 2 index 0 get 1 5 index 1 add lines exch get 0 get 1 sub {layout_word pop pop pop} for pop pop pop pop} def /print_line {dup lines exch get dup line_height 1 index 2 get dup 4 index 1 add lines exch get 2 get exch sub 3 1 roll llx exch sub 3 index 3 get ury exch sub gsave newpath llx 1 index dL add Emaxht dEA mul add moveto 3 index clipdx2 add 0 rlineto 0 3 index dL add Emaxht Emaxhb add dEA mul add neg rlineto 3 index clipdx2 add neg 0 rlineto closepath bggray 0 lt not {gsave bggray setgray fill grestore} if clip framegray 0 lt not {gsave framegray setgray stroke grestore} if newpath 4 2 roll pop pop textfont setfontsize setupfont 2 index 0 get 1 5 index 1 add lines exch get 0 get 1 sub {print_word} for smallfont setfontsize setupfont 3 index 0 eq {[]} {3 index 1 sub lines exch get 6 get} ifelse {print_edge_cross} forall 3 index 0 eq {0} {3 index 1 sub lines exch get 1 get} ifelse 1 4 index 1 get 1 sub {print_edge} for grestore pop pop pop pop} def /layout_lines {0 1 lines length 2 sub {layout_line} for lines dup length 1 sub get 7 lines dup length 2 sub get 7 get put /nword 0 def} def /print_lines {0 1 lines length 2 sub {dup print_line 1 add lines exch get 3 get 0 eq {alignments {aload pop align} forall showpage} if} for} def /draw {currentdict /title known {llx titley moveto title {show} 0 format} if layout_arcs layout_lines print_lines} def /min {2 copy lt {pop} {exch pop} ifelse} def /setup {array /edges exch def dup array /words exch def array /widths exch def /nextw 0 def /nexte 0 def /strings exch def /dT dT Emaxht EmaxhtMax min dEA mul add def /dB dB Emaxhb EmaxhbMax min dEA mul add def /xwords words length array def /ywords words length array def /ypwords words length array def /nword 0 def /alignments [] def} def true (ptm) /Times-Roman /Times-Bold /Times-Italic /Times-BoldItalic createfontfamily setfontfamily 10 setfontsize 0 setfontstyle 0 setarrowtype setupfont /align {3 1 roll dup type (arraytype) ne {xyword moveto} {dup dup xmid exch 0 get xyword dA add exch pop 3 2 roll {xyword moveto 2 copy lineto} forall moveto} ifelse currentpoint 3 2 roll dup type (arraytype) ne {xyword topadjust lineto currentpoint} {dup dup xmid exch 0 get xyword topadjust dA sub exch pop 2 copy lineto 3 2 roll {xyword topadjust moveto 2 copy lineto} forall} ifelse gsave currentlinewidth 5 mul setlinewidth 1 setgray stroke grestore stroke 3 -1 roll add 2 div 3 1 roll add 2 div exch moveto cshowbgfill} def /topadjust {strings dH mul sub 4 sub} def /fixbotadjust {strings dH mul sub} def /xyword {dup xwords exch get exch ywords exch get} def /xmid {dup 0 get xwords exch get exch dup length 1 sub get xwords exch get add 2 div} def /formats [] def 

