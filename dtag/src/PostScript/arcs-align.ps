%! (c) 2002-2004 Matthias T. Kromann <mtk@id.cbs.dk>

%% This PostScript library is distributed under the GNU public  
%% license for libraries, as part of the DGgraph package.
%% Please see: http://www.id.cbs.dk/~mtk/DGgraph for source code,
%% documentation and license.

%% 1. DGgraph Prologue

%%BeginPrologue
%% DATA STRUCTURES:
%%     word = [x, string1, format1, ..., stringS, formatS]
%%     edge = [wmin, +/- wmax, label, height, dx, labelformat, arcformat, cent]
%%     line = [w0 e0 x0 y0 maxht maxhb [cross1 cross2 ...]]
%%     segment = [w1 w2 height edge1 ... edgeN]
%%
%% FORMATTING:
%%		edge: color, linewidth, dash
%%		label: color, bgcolor, roman/bold/italic/bolditalic
%%		elabel: color, bgcolor, roman/bold/italic/bolditalic

100 dict begin

% Parameters
/llx 20 def			% X-coordinate of lower left corner
/lly 20 def			% Y-coordinate of lower left corner
/urx 500 def 		% X-coordinate of lower left corner
/ury 810 def		% Y-coordinate of lower left corner
/titley 820 def		% Y-coordinate of title

/LW 1 def			% line width
/X 2 def			% Current X-coordinate
/Y 0 def			% Current Y-coordinate

/dO 5 def			% arrow displacement
/dA 10 def			% unit height of arc
/dAW 2.5 def		% arc head width
/dAH 6 def			% arc head height
/dAD 2 def			% arc displacement
/dT 15 def 			% top edge label height
/dB 18 def 			% bottom edge label height
/dT0 3 def			% top edge label offset from bottom line
/dB0 8 def			% bottom edge label offset from bottom line
/dW 4 def			% word-word distance
/dH 10 def			% unit height of single label line
/dL 20 def			% vertical distance between entire lines
/center false def	% center edge labels at the middle of each edge by default

/strings 1 def		% number of strings in label
/framegray -1 def	% gray level of frame around lines
/bggray -1 def		% gray level of graph background
/smallfont 7 def
/textfont 10 def

/charstroke smallfont 0.4 mul def
/dy_lbl smallfont -0.3 mul def

/nextw 0 def
/nexte 0 def

% Initialize
LW setlinewidth

% Functions
/xdef {
	exch def
} def


% max: num1 num2 => max
/max {
    dup 3 -1 roll dup 3 -1 roll lt {pop} {exch pop} ifelse
} def


% min: num1 num2 => min
/min {
    dup 3 -1 roll dup 3 -1 roll gt {pop} {exch pop} ifelse
} def


%% Font setup
% Convert font to ISO-Latin1 encoded font
/ISOfont % font ISOfont
{   findfont
    dup length dict begin
       {1 index /FID ne {def} {pop pop} ifelse} forall
       /Encoding ISOLatin1Encoding def
       currentdict
    end
    definefont pop
} def

/setfontfamily {/fontfamily xdef} def
/setfontsize {/fontsize xdef} def
/setfontstyle {/fontstyle xdef} def
/font 7 string def
/fontext 4 string def
/setupfont
    {   font 0 fontfamily 0 get putinterval
        font 3 fontstyle 1 add 1000 mul fontsize cvi add
        fontext cvs putinterval
        currentdict font cvn known not
            {   currentdict font cvn fontfamily fontstyle 1 add get
                    findfont fontsize scalefont put
            } if
        font cvn cvx exec setfont
    } def

% setupfonts: iso? ext romanfont boldfont italicfont bolditalicfont
/createfontfamily {
	5 array astore exch					% fontfamily iso?
	{	% Generate ISO encodings		% fontfamily
		dup dup 1 get /Palatino-Roman-isolatin1 
			dup 3 1 roll exch ISOfont 1 exch put
		dup dup 2 get /Palatino-Bold-isolatin1 
			dup 3 1 roll exch ISOfont 2 exch put
		dup dup 3 get /Palatino-Italic-isolatin1 
			dup 3 1 roll exch ISOfont 3 exch put
		dup dup 4 get /Palatino-BoldItalic-isolatin1 
			dup 3 1 roll exch ISOfont 4 exch put
	} if
} def

% qsort: array cmp_proc => sorted
/qsort {
	1 index length 0 exch 							% array cmp 0 n
	qsortx pop
} def


% qsortx: array cmp_proc start stop => subsorted cmp
/qsortx {										
	% Subarray is sorted if r-l < 2
	2 copy 2 sub gt {								% array cmp l r
		% Subarray is sorted
		pop pop										% array cmp
	} {												% array cmp l r
		% Find pivot value and exit if -1
		findpivot									% array cmp l r ipivot
		dup -1 eq {
			% All values in array are identical, hence sorted
			pop pop pop								% array cmp
		} {
			% Find pivot value
			4 index exch get 3 1 roll				% array cmp ap l r
			2 copy 7 2 roll 1 sub					% l r array cmp ap l1 r1
									
			% Split subarray into two around pivot
			{	% Move left cursor over any elements < pivot
				exch								% array cmp ap r1 l1
				{	
					dup 5 index exch get 3 index	% array cmp ap r1 l1 al1 ap
					5 index exec 					% array cmp ap r1 l1 <=>
					-1 eq {1 add} {exit} ifelse		% array cmp ap r1 l1
				} loop
				exch

				% Move right cursor over any elements >= pivot
				{	dup 5 index exch get 3 index	% array cmp ap l1 r1 v ap
					5 index exec 					% array cmp ap l1 r1 <=>
					-1 gt {1 sub} {exit} ifelse		% array cmp ap l1 r1
				} loop

				% Exit if l > r
				2 copy gt {exit} if					% array cmp ap l1 r1

				% Switch elements pointed to by l and r, and repeat
				2 copy 6 index 3 1 roll switch		% array cmp pivot l1 r1
			} loop
			3 -1 roll pop pop 						% l r array cmp k

			% Sort two subarrays recursively
			5 -1 roll exch dup 6 1 roll				% k r array cmp l k
			qsortx									% k r array cmp
			4 2 roll qsortx							% array cmp
		} ifelse
	} ifelse
} def


% findpivot: array cmp l r => array cmp l r pi (array must have length>1)
/findpivot {
	% Find middle index and value
	2 copy add 1 sub 2 idiv							% A cmp l r m
	4 index 1 index get								% A cmp l r m am

	% For i:=m to m+(r-l), until am != ai
	1 index 1 1 index 5 index add 6 index sub 1 sub
													% A cmp l r m am m+1 1 m+r-l
	{ 												% A cmp l r m am i
		% Subtract r-l if i>=r
		dup 4 index ge {
			4 index add 3 index sub					
		} if										% A cmp l r m am i

		% Exit if am != ai
		dup 7 index	exch get 2 index				% A cmp l r m am i ai am
		7 index exec dup 0 ne {						% A cmp l r m am i <=>
			1 eq {									% A cmp l r m am i
				% Return i := i and set m := -1
				3 -1 roll pop -1 3 1 roll 			% A cmp l r -1 am i
				exit
			} {										% A cmp l r m am i
				% Return i := m and set m := -1
				pop -1 3 1 roll exch				% A cmp l r -1 am m
				exit
			} ifelse
		} {
			pop pop									% A cmp l r m am
		} ifelse
	} for

	% This procedure returns: "A cmp l r -1 am i" OR "A cmp l r m am"

	% Return -1 if m != -1, else i
	2 index -1 eq {									% A cmp l r -1 am i
		3 1 roll pop pop 							% A cmp l r i
	} {												% A cmp l r m am
		pop pop -1									% A cmp l r -1
	} ifelse
} def


% switch: array i j => -
/switch {
	2 index 2 index	get								% A i j ai
	3 index 2 index get								% A i j ai aj
	4 index	exch 6 1 roll 3 1 roll					% aj A i A j ai
	put 											% aj A i
	3 -1 roll put
} def


% intcmp: a b => sign(a-b)
/intcmp {
    2 copy lt {
        pop pop -1
    } {
        eq {0} {1} ifelse
    } ifelse
} def

% format: format procedure type => -
/format {
	% Process format type (0=word, 1=arclabel, 2=arc)
	pop 
	
	% Save graphical state (including fonts)
	gsave
	/oldfontstyle fontstyle def
	/oldfontsize fontsize def
	/oldfontfamily fontfamily def
	exch

	% Change format, if unequal to last format and in 0...formats
	dup 0 ge							% format bool
	1 index formats length le and		% format bool
	{
		% Retrieve format
		dup 0 eq {
			% Format = 0: do nothing
			pop
		} {
			% Format > 0: execute formatting commands
			formats exch 1 sub get exec
		} ifelse
	} {
		pop
	} ifelse

	% Execute procedure
	exec

	% Restore graphics state and font
	grestore
	fontstyle oldfontstyle ne 
		fontsize oldfontsize ne or
		fontfamily oldfontfamily ne or
	{
		oldfontfamily setfontfamily 
		oldfontsize	setfontsize 
		oldfontstyle setfontstyle
		setupfont	
	} if
} def

% Arrows
/arrowlbl % xi y0 xo dy lbl				
{	5 1 roll						% lbl xi y0 xo dy
	dA mul 2 index add 	 			% lbl x0 y0 x1 y1

	% Draw centered label
	5 -1 roll 						% x0 y0 x1 y1 lbl
	4 index	3 index add 2 div		% x0 y0 x1 y1 lbl xc
	2 index 5 index sub 0.75 mul 	% x0 y0 x1 y1 lbl xc yc'
	5 index add						% x0 y0 x1 y1 lbl xc yc
	moveto							% x0 y0 x1 y1 lbl
	dup stringwidth pop -2 div	 	% x0 y0 x1 y1 lbl -w/2
	dy_lbl							% x0 y0 x1 y1 lbl -w/2 dy
	rmoveto							% x0 y0 x1 y1 lbl

	% Print outline first in white, then print the real thing
	0 currentlinewidth eq {
		pop
	} {
		gsave
			dup 0 setlinecap [] 0 setdash true charpath charstroke 
			setlinewidth 1 setgray stroke
		grestore
		show							% x0 y0 x1 y1
	} ifelse

	% Clean up stack
	pop pop pop pop					% -
} def


/arrow % xi y0 xo dy 
{	dA mul 2 index add 	 				% x0 y0 x1 y1

	% Draw arrow curve from x1 to x0
	4 copy 								% ... x0 y0 x1 y1
	exch 2 copy							% ... x0 y0 y1 x1 y1 x1
	5 index 5 1 roll 5 index			% ... x0 y0 x0 y1 x1 y1 x1 y0
	8 -2 roll moveto					% ... x0 y1 x1 y1 x1 y0
	curveto								% ...
	currentlinewidth 0 eq 
		{newpath} {stroke} ifelse		% x0 y0 x1 y1

	% Draw arrow-head
	2 index	gt {-1} {1} ifelse dAH mul	% x0 y0 x1 dh
	3 1 roll exch						% x0 dh x1 y0
	moveto dAW 0 rmoveto				% x0 dh
	dAW -2 mul 0 rlineto
	dAW exch rlineto pop				% 
	closepath 
	currentlinewidth 0 eq
		{newpath} {fill} ifelse		
} def 


% word: s1 [format1] ... sS [formatS] => [w, s1, format1, ... sS, formatS]
/word {
	% Create array
	strings 2 mul 1 add array			% s1... W
	strings -1 1 {						% s1... W I
		% Extract label and format
		2 index type /integertype eq {	% s1... sI formatI W I
			4 2 roll					% s1... W I sI formatI
		} {								% s1... sI W I
			3 -1 roll 0					% s1... W I sI formatI
		} ifelse						% s1... W I sI formatI

		% Save label and format
		3 index 3 index 2 mul 3 -1 roll % s1... W I sI W 2I formatI
		put								% s1... W I sI
		2 index	2 index 2 mul 1 sub 	% s1... W I sI W 2I-1
		3 -1 roll 						% s1... W I W 2I-1 sI
		put pop							% s1... W
	} for								% W

	% Find maximal width of all strings and store in widths array
	0 1 1 strings { 					% W wmax I
		2 index exch 2 mul 1 sub get 	% W wmax sI
		stringwidth pop 				% W wmax swidth
		max								% W wmax 
	} for								% W wmax
	widths nextw 3 -1 roll put			% W
	dup 0 0 put							% W

	% Store word
	currentdict /words known {words nextw 3 -1 roll put} if
	/nextw nextw 1 add def
} def

% newedge: imin imax label [lblformat [arcformat]] => edge
/newedge {
	% Ensure formats are specified
	dup type /stringtype eq {			% imin imax label
		0 0								% imin imax label lfmt afmt
	} {										
		1 index type /stringtype eq {	% imin imax label lfmt
			dup							% imin imax label lfmt afmt
		} if							% imin imax label lfmt afmt
	} ifelse							% imin imax label lfmt afmt
	5 2 roll 							% lfmt afmt imin imax label

	% Calculate wmin, wmax, label
	3 1 roll 2 copy gt {exch neg} if 	% lfmt afmt label wmin wmax
	3 -1 roll 0 1						% lfmt afmt wmin wmax label height dx
	7 -2 roll							% wmin wmax label height dx lfmt afmt
	center 8 array astore
} def

% edget: imin imax label [lblformat [arcformat]] => edge
/edget {
	% Create edge object
	newedge

	% Store edge
	currentdict /edges known {edges nexte 3 -1 roll put} if
	/nexte nexte 1 add def
} def


% edgeb: imin imax label [lblformat [arcformat]] => edge
/edgeb {
	% Create edge object
	newedge
	dup 4 -1 put

	% Store edge
	currentdict /edges known {edges nexte 3 -1 roll put} if
	/nexte nexte 1 add def
} def


% xcenter: i => xcenter
/xcenter {
	% Unload word and compute xcenter
	dup words exch get 0 get exch 		% x0 i
    1 add dup words length eq           % x0 i1 bool
        {pop X} 
		{words exch get 0 get} ifelse   % x0 x1
	dW sub add 2 div					% xcenter
} def

% Segment data structure:
%
% 	segment = [w1-w2|height|wf1,wf2,...,wfN]
%
%		w1=start word
%		w2=end word   (w2>w1)
%		wfi=end word of edge w1-wfi with wfi>w1
%		height=height of all edges between w1 and w2, excluding edges 
%			wf1,...,wfN
%
% Segments are placed on a stack. Reductions:
%
%	1. [w1-w2|h1|E] + [w3-w4|h2|], w2>=w3 => [w1-w4|max(h1,h2)|E]
%   2. [w1-w2|h|w2,E] => [w1-w2|h+1|E]
%	3. [w1-w2|h1|E1] + ([w3-w4|h2|E2]), w1<=w3<=w2<w4 => [w1-w2|max(h1,h2)|E1]
%		then reduce rest of stack with 1-3
%	4. => [i-(i+1)|0|forward-edges(i)]

% edge_heights: - => -
%	s0 ... sN sign nextword nextedge N continue
/edge_heights {
	% Initialize
	[ exch 0 0 0 							% [ sgn nw ne N 

	% Reduce stack
	edge_heights0							% [ s0 ... sN sgn nw ne N

	% Empty stack
	{pop} repeat pop pop pop pop
} def


/edge_heights0 {
	% Reduce stack
	{										% s0 ... sN sgn nw ne N
		% Perform edge_height operations until one succeeds
		edge_heights1
		{true} {edge_heights2} ifelse
		{true} {edge_heights3} ifelse
		{true} {edge_heights4} ifelse

		% Stop computation if no operation succeeded
		not {exit} if
	} loop									% s0 ... sN sgn nw ne N
} def

% edge_heights1: s0...sN sgn nw ne N => s0...sM sgn nw ne M cont
/edge_heights1 {
	% Check whether N>1 and top segment is completed
	dup 2 lt {								% s0...sM sgn nw ne N
		false								
	} {
		4 index length 3 eq {				% s0...sM sgn nw ne N 
			% Top segment has no edges
			true
		} {									% s0...sM sgn nw ne N
			% Succeed if top segment has an edge
			4 index 3 get -1 eq 
		} ifelse							% s0...sM sgn nw ne N cont
	} ifelse

	% Join two top segments if cont=true
	{										% ...sM1 sM sgn nw ne N 
		5 -1 roll dup						% ...sM1 sgn nw ne N sM sM
		1 get exch 2 get					% ...sM1 sgn nw ne N sMw1 sMh
		6 index	dup	dup 					% ... sMw1 sMh sM1 sM1 sM1

		% Update maxh
		2 get 4 -1 roll	max	2 exch put		% ... sMw1 sM1 

		% Update w1
		1 3 -1 roll put 1 sub true			% ... N1 true
	} {false} ifelse
} def

% edge_heights2:
/edge_heights2 {							% s0...sM sgn nw ne N
	% Check that N > 0
	dup 0 gt {
		4 index length 3 gt {
			% Top segment contains an edge
			4 index 3 get -1 ne {
				% Edge is undeleted
				4 index dup dup					% ... sM sM sM
				1 get exch 3 get				% ... sM w1 e
				edges exch get 1 get abs		% ... sM w1 w1'
				eq {							% ... sM
					% Increase height
					dup dup 					% ... sM sM sM
					2 get 1 add 2 exch dup 		% ... sM sM 2 maxh maxh
					4 1 roll put				% ... sM maxh

					% Save height in edge
					1 index 3 get 				% ... sM maxh e
					edges exch get				% ... sM maxh edge
					3 3 -1 roll 				% ... sM edge 3 maxh
					7 index exec put			% ... sM

					% Rotate edges
					mark exch dup				% ... [ sM sM
					aload pop					% ... [ sM w0 w1 maxh e1...eN
					counttomark 4 sub -1 roll	% ... [ sM w0 w1 maxh e2...eN e1
					pop -1 						% ... [ sM w0 w1 maxh e2...eN -1
					counttomark -1 roll			% ... [ w0 w1 maxh e2...eN -1 sM
					astore pop pop				% ...
					true						% s0...sM sgn nw ne N true
				} {
					% w1 != w1'
					pop false					% s0...sM sgn nw ne N false
				} ifelse
			} {
				% Edge is deleted 
				false
			} ifelse
		} {
			% Top segment has no edges
			false
		} ifelse
	} { 
		false
	} ifelse
} def

%	3. [w1-w2|h1|E1] + ([w3-w4|h2|E2]), w1<=w3<=w2<w4 => [w1-w4|max(h1,h2)|E1]
%		then reduce rest of stack with 1-3
% edge_heights3:
/edge_heights3 {						% s1...sN sgn nw ne N 
	% Check that N>1
	dup 1 gt {
		% Check that 2nd segment ends before 1st segment
		5 index 5 index					% s1...sN sgn nw ne N sN1 sN
		dup 1 get exch 2 get			% s1...sN sgn nw ne N sN1 sNw1 sNh
		3 -1 roll 1 get					% s1...sN sgn nw ne N sNw1 sNh sN1w1
		2 index ne {					% s1...sN sgn nw ne N sNw1 sNh
			% Segments do not end in same place: combine sN-1 and sN
			7 index dup 				% s1...sN sgn nw ne N sNw1 sNh sN1 sN1
			1 5 -1 roll put				% s1...sN sgn nw ne N sNh sN1	
			dup 2 get 3 -1 roll max		% s1...sN sgn nw ne N sN1 sN1h'
			2 exch put					% s1...sN sgn nw ne N

			% Pop off sN (store before bottom of stack)
			5 -1 roll					% s1...sN1 sgn nw ne N sN
			1 index 4 add 1 roll 1 sub	% sN s1...sN1 sgn nw ne N-1
			
			% Reduce stack
			edge_heights0				% sN s1...sN' sgn nw ne N'

			% Restore sN				% sN s1...sN1 sgn nw ne N-1
			1 add dup 4 add -1 roll		% s1...sN1 sgn nw ne N sN
			5 1 roll					% s1...sN sgn nw ne N

			% Return true
			true
		} {
			pop pop false
		} ifelse
	} { 
		false
	} ifelse
} def

% edge_heights4: s0...sN-1 sgn nw ne N => s0...sN sgn nw ne N cont
/edge_heights4 {
	% Check that we are not recursively reducing stack (ie, distance
	% to mark is N+4)
	counttomark 1 index 4 add eq {
		% Check that nw does not exceed number of words
		2 index words length lt {
			% Read next word
			mark 3 index dup 1 add 0		% sgn nw ne N [ w0 w1 0
			7 index	6 index					% sgn nw ne N [ w0 w1 0 sgn ne

			% Read edges starting at w0
			{	% Exit if ne>#edges			% ... [...w0 w1 0 sgn ne
				dup edges length ge {
					exch pop exit			% ... [...w0 w1 0 ne
				} if

				% Read next edge, and exit if edge[ne].0 != w0
				dup edges exch get dup 0 get% ... [...w0 w1 0 sgn ne e ew0
				6 index eq {				% ... [...w0 w1 0 sgn ne e
					4 get 2 index exec 0 gt{% ... [...w0 w1 0 sgn ne 
						dup 6 1 roll 		% ... [...ne w0 w1 0 sgn ne
					} if 
					1 add					% ... [...ne w0 w1 0 ne+1
				} {							% ... [...w0 w1 0 sgn ne e
					pop exch pop exit		% ... [...w0 w1 0 ne 
				} ifelse
			} loop							% sgn nw* ne* N [e1...eM w0 w1 0 ne

			% Close segment and update nw and ne
			counttomark 1 add 1 roll		% sgn nw* ne* N ne [e1...eM w0 w1 0
			counttomark 3 roll ]			% sgn nw* ne* N ne [w0 w1 0 e1...eM]
			6 1 roll						% sN sgn nw* ne* N ne

			3 1 roll 1 add exch pop			% sN sgn nw* ne N+1
			3 -1 roll 1 add 3 1 roll true	% sN sgn nw ne N+1 true
		} {
			false							% sgn nw ne N false
		} ifelse
	} {
		false
	} ifelse
} def

% Edge displacement
/edge_displace {
	% wordt wordb word nemin nemax 
	-1 -1 0 0 0

	% Process each word
	{	
		% Exit if current word does not exist
		2 index words length ge {				% wt wb w en ex
			pop pop pop pop pop exit
		} if
		
		% Update wordt and wordb for current word
		5 -2 roll pop pop -1 -1 5 2 roll		% -1 -1 w en ex
		1 index edges 0	3 -1 roll update_super	% wt wb w en ex
		dup maxedges 1 3 -1 roll update_super	% wt wb w en ex

		% Assign displacements to out-edges from w
		exch edges 0 3 -1 roll displace exch	% wt wb w en' ex
		maxedges 1 3 -1 roll displace			% wt wb w en ex'

		% Increment word
		3 -1 roll 1 add 3 1 roll				% wt wb w' en ex
	} loop
} def

% displace: wt wb w * edges i e => wt wb w * e'
/displace {
	{	% Exit if e >= #E						
		dup 3 index length ge {					% wt wb w * E i e
			3 1 roll pop pop exit				% wt wb w * e
		} if									% wt wb w * E i e

		% Exit if E[e].i > w
		2 index 1 index get						% wt wb w * E i e edge
		dup 3 index get abs						% wt wb w * E i e edge wi
		6 index gt {							% wt wb w * E i e edge
			pop 3 1 roll pop pop exit			% wt wb w * e
		} if									% wt wb w * E i e edge
		
		% Check that edge points to w
		dup ioword 								% wt wb w * E i e edge wi wo
		7 index eq {							% wt wb w * E i e edge wi
			% Check top/bottom edge
			1 index 3 get 0 gt {				% wt wb w * E i e edge wi
				% Top edge
				8 index
			} {
				% Bottom edge
				7 index
			} ifelse							% ... edge wi wtb

			% Assign offset
			dup -1 eq {							% ... edge wi wtb
				% No in-edge for w 
				pop pop 4 0 put					% ...
			} {	
				% w has in-edge from wtb (-1 = sign if in-between wtb and w)
				7 index -1						% ... edge wi wtb w sgn

				% Order wtb<w, inverting sign if necessary
				2 index 2 index gt {			% ... edge wi wtb w sgn
					% wtb > w
					neg exch 3 1 roll			% ... edge wi w wtb -sgn
				} if							% ... edge wi w1 w2 sgn
				4 1 roll						% ... edge sgn wi w1 w2

				% Check whether wi is between w1 and w2
				2 index gt 3 1 roll gt and not {% ... edge sgn
					% Not in-between: negate sign
					neg
				} if

				% Store sign
				4 exch put						% ...
			} ifelse
		} {										% wt wb w * E i e edge wi
			pop pop								% wt wb w * E i e
		} ifelse

		% Increment e
		1 add
	} loop
} def

% update_super: wt wb w en ex edges i e => wt wb w en ex
/update_super {									% wt wb w en ex edges i e
	% Look forward in E to update wordt and wordb
	{	
		% Exit if e >= #E						% wt wb w en ex E i e
		dup 3 index length ge {					% wt wb w en ex E i e
			pop pop pop exit					% wt wb w en ex
		} if									% wt wb w en ex E i e

		% Exit if E[e].i > w
		2 index 1 index get						% wt wb w en ex E i e edge
		dup 3 index get 						% wt wb w en ex E i e edge wi
		7 index gt {							% wt wb w en ex E i e edge
			pop pop pop pop exit				% wt wb w en ex
		} if									% wt wb w en ex E i e edge
		
		% Check that in-word = w
		dup ioword exch							% wt wb w en ex E i e edge wo wi
		8 index eq {							% wt wb w en ex E i e edge wo
			% Update wt and wb
			exch 3 get							% wt wb w en ex E i e wo h
			0 gt {								% wt wb w en ex E i e wo
				% Replace wt with wo
				9 -1 roll pop 8 1 roll			% wo wb w en ex E i e
			} {
				% Replace wb with wo
				8 -1 roll pop 7 1 roll			% wt wo w en ex E i e
			} ifelse
		} {
			pop pop
		} ifelse								% wt wb w en ex E i e

		% Increase edge
		1 add									% wt wb w en ex E i e+1
	} loop										% 
} def 

% edge => in out
/ioword {										% edge
	dup 0 get exch 1 get 						% w0 w1
	dup 0 lt {									% w0 w1
		abs exch 								% wi wo
	} {
		abs 									% wi wo
	} ifelse
} def


% split_lines: - => -
/split_lines {
	% Process words (w0 x0): split words into lines until no words left
	split_words

	% Process edges (e0 maxht maxhb cross): compute edge boundaries,
	% maximal heights and cross edges
	split_edges

	% Place lines on pages (y0)
	split_pages
} def

% split_words: - => -
/split_words {
	/lines [
	urx llx sub 0 0 1 							% maxw x0 i0 i
	{	% Read lines until no words left (ie, i0>=#words)
		1 index words length ge {				% maxw x0 i0 i
			pop pop pop pop 
			exit
		} if

		% Create next line object				% maxw x0 i0 i
		[2 index 0 5 index 0 0 0 0] 5 1 roll	% line maxw x0 i0 i

		% Read next line
		{	% Read mw width words				% maxw x0 i0 i 
			dup xpos dW 2 div sub dup			% maxw x0 i0 i xi xi
			4 index sub							% maxw x0 i0 i xi width

			% Exit if width > maxwidth or i>#W
			5 index gt 							% maxw x0 i0 i xi bool
			2 index newline or					% maxw x0 i0 i xi bool
			2 index words length ge or {		% maxw x0 i0 i xi 
				exch 4 2 roll pop pop dup 1 add	% maxw xi i i+1
				exit
			} if								% maxw x0 i0 i xi

			% Increment i
			pop	1 add							% maxw x0 i0 i
		} loop
	} loop										% 
	[words length edges length X 0 0 0 0]
	] def
} def

/split_edges {
	% Process edges: compute e0, maxht, maxhb and cross-edges
	0 [] 										% e0 cross
	0 1 lines length 2 sub {					% e0 C il

		% Initialize parameters
		dup 1 add lines exch get 0 get exch		% e0 C w1 il
		lines exch get 0 0 						% e0 C w1 L hmn hmx
		2 index [ 8 2 roll						% L [ e0 C w1 L hmn hmx

		% Copy edges in C with e.wmax>=w1
		4 index {								% .. e0 C w1 L hmn hmx e 

			% Add cross-edge to new cross-edges, if necessary
			dup edges exch get 1 get abs		% .. e0 C w1 L hmn hmx e e.wmax
			5 index ge {						% .. e0 C w1 L hmn hmx e
				dup 8 1 roll					% .. e e0 C w1 L hmn hmx e 
			} if								% .. e e0 C w1 L hmn hmx e

			% Update hmn and hmx
			edges exch get 3 get				% .. e0 C w1 L hmn hmx h
			dup 4 -1 roll min 3 1 roll max		% .. e0 C w1 L hmn' hmx'
		} forall								% [ ... e0 C w1 L hmn hmx

		% Process edges until e0.min>w1
		{
			% Exit if e0>=#edges				% ... e0 C w1 L hmn hmx
			5 index edges length ge {
				exit							% ... e0 C w1 L hmn hmx
			} if

			% Exit if e0.min>w1
			5 index edges exch get 0 get 		% ... e0 C w1 L hmn hmx e0.min
			4 index ge {						% ... e0 C w1 L hmn hmx
				exit							% ... e0 C w1 L hmn hmx
			} if

			% Add e0 to cross-edges if e0.wmax>=w1
			5 index edges exch get				% ... e0 C w1 L hmn hmx edge
			dup 1 get abs 5 index ge {			% ... e0 C w1 L hmn hmx edge
				6 index 7 1 roll				% ... e0 e0 C w1 L hmn hmx edge
			} if

			% Update hmn and hmx
			3 get dup 4 -1 roll min				% ... e0 C w1 L hmx h hmn'
			3 1 roll max						% ... e0 C w1 L hmn' hmx'

			% Increase e0
			6 -1 roll 1 add 6 1 roll			% ... e1
		} loop									% L [ ... e0 C w1 L hmn hmx

		% Update line L
		2 index 4 3 -1 roll put					% L [ ... e0 C w1 L hmn 
		1 index 5 3 -1 roll abs put				% L [ ... e0 C w1 L 
		3 1 roll pop pop 						% L [ ... e0 L
		1 2 index put							% L [ ... e0
		counttomark 1 add 1 roll ]				% L e0 [ ... ]
		2 index 6 2 index put 					% L e0 C1
		3 -1 roll 1 3 index put					% e0 C1
	} for										% e0 C1
	pop pop
} def

% split_pages: - => -
/split_pages {
	% Process lines
	ury lly sub 0 								% ymax y
	0 1 lines length 2 sub {					% ymax y l
		lines exch get							% ymax y L

		% Compute line height = (ht+hb)*dA + S*dH + dB + dT
		dup line_height							% ymax y L height

		% Reset y to 0 if y+height>ymax
		3 index 3 index 2 index add lt {		% ymax y L height
			3 -1 roll pop 0 3 1 roll			% ymax 0 L height
		} if

		% Set line height to y and update y += height + dL
		exch 3 3 index put						% ymax y height
		add dL add								% ymax y
	} for
	pop pop
} def

% line_height: Line => height
/line_height {
	dup 4 get exch 5 get add dA mul			% (ht+hb)*dA
	strings dH mul add dB add dT add		% (ht+hb)*dA + S*dH + dB + dT
} def

% xpos: iword => xpos
/xpos {
	dup words length ge {						% i
		% Return X if i>=#Words
		pop X
	} {											% i
		words exch get 0 get
	} ifelse
} def

/newline {								% i
	1 sub
	dup words length ge 1 index 0 lt or {
		pop false
	} {
		words exch get 1 get (\n) eq 
	} ifelse
} def

% print_word: L dx y0 w => L dx y0
/print_word { 							% L dx y0 i
	% Compute ypos = y0-(maxht*dA)-dT
	1 index 							% L dx y0 i y0
	4 index 4 get dA mul sub dT sub		% L dx y0 i y
	
	% Compute xcenter
	1 index xcenter						% L dx y0 i y xc
	4 index add exch					% L dx y0 i xc y

	% Save xcenter and y in /xwords and /ywords arrays
	xwords nword 3 index put
	ywords nword 2 index put

	% Print label l around (xc,y-(l+1)*dH)
	3 -1 roll words exch get			% L dx y0 xc y W
	1 1 strings {						% L dx y0 xc y W i
		3 -1 roll dH sub 3 1 roll		% L dx y0 xc y' W i
		2 copy 2 mul get 3 1 roll		% L dx y0 xc y' format W i 
		1 index exch 2 mul 1 sub get 	% L dx y0 xc y' format W str
		dup stringwidth pop 2 div neg	% L dx y0 xc y' format W str -w/2
		5 index add 4 index moveto		% L dx y0 xc y' format W str 
		3 -1 roll 						% L dx y0 xc y' W str format
		{show} 0 format 				% L dx y0 xc y' W
	} for
	pop pop pop							% L dx y0 

	% Increment nwords
	/nword nword 1 add def
} def

% print_edge: L dx y0 e => L dx y0
/print_edge {
	% Retrieve edge 
	edges exch get 1 index						% cnt L dx y0 E y
	1 index 7 get true eq 6 1 roll

	% Calculate y and yl for label
	4 index 4 get dA mul sub					% cnt L dx y0 E y'
	1 index 3 get 0 ge {
		% Top edge
		dup dT sub dT0 add						% cnt L dx y0 E y yl
	} { 
		% Bottom edge
		dT sub strings dH mul sub dB sub		% cnt L dx y0 E y
		dup dB0 add								% cnt L dx y0 E y yl
	} ifelse

	% Compute xcenters
	2 index ioword								% cnt L dx y0 E y yl wi wo
	xcenter 6 index add 						% cnt L dx y0 E y yl wi xo
	exch xcenter 6 index add					% cnt L dx y0 E y yl xo xi

	% Print label above in-word
	dup 4 -1 roll moveto						% cnt L dx y0 E y xo xi
	7 index not {
		3 index 2 get 							% cnt L dx y0 E y xo xi lbl
		dup stringwidth pop -2 div 0 rmoveto	% cnt L dx y0 E y xo xi lbl
		4 index 5 get {
			currentlinewidth 0 eq 
				{pop} {show} ifelse
		} 1 format 								% cnt L dx y0 E y xo xi
	} if

	% Print arrow
	exch 3 index 4 get dO mul add 3 1 roll		% cnt L dx y0 E xo' y xi
	3 index 3 get		 						% cnt L dx y0 E xo y xi h
	4 copy										% ... E xo y xi h xo y xi h
	8 index 6 get {arrow} 2 format				% cnt L dx y0 E xo y xi h

	% Print centered label
	8 index {
		4 index 2 get 							% cnt L dx y0 E xo y xi h lbl
		5 index 5 get {arrowlbl} 1 format		% cnt L dx y0 E
	} {
		pop pop pop pop							% cnt L dx y0 E
	} ifelse

	% Clean up stack
	pop	4 -1 roll pop							% L dx y0
} def

% sort_edges: - => -
/sort_edges {
	% Sort edges, ordered by minimal word
	edges {									% edge1 edge2 
		2 copy								% edge1 edge2 edge1 edge2
		0 get exch 0 get exch intcmp dup	% edge1 edge2 cmp cmp
		0 ne {								% edge1 edge2 cmp
			3 1 roll pop pop				% cmp
		} {									% edge1 edge2 cmp
			pop 							% edge1 edge2
			1 get abs exch 1 get abs exch	% wmax1 wmax2
			intcmp							% cmp2
		} ifelse
	} qsort pop

	% Sort edges, ordered by maximal word
	/maxedges edges edges length array copy def
	maxedges {
		2 copy
		1 get abs exch 1 get abs exch intcmp dup
		0 ne {
			3 1 roll pop pop
		} {
			pop 
			0 get exch 0 get exch
			intcmp
		} ifelse
	} qsort pop
} def

% Compute which edges must have a centered label (ie, when the edge's
% in-node has more than one in-coming edge at the bottom/top
% respectively)
/center_edge_label {
	% Create arrays that encode the number of in-coming top/bottom
	% edges for each node
	words length array 				% tin
	words length array 				% tin bin
	0 1 words length 1 sub {		% tin bin i
		dup 3 index exch 0			% tin bin i tin i 0 
		put							% tin bin i
		1 index exch 0				% tin bin bin i 0
		put							% tin bin
	} for							% tin bin

	% Set edge font
	smallfont setfontsize setupfont

	% Record each edge in tin and bin
	edges {							% tin bin edge
		% Record number of incoming edges for each node at top and bottom
		edgein						% tin bin in top?
		1 index 5 1 roll			% tin bin in top?
		{	dup 3 index exch get	% tin bin in count
			1 add					% tin bin in count+1
			3 index 3 1 roll put	% tin bin
		} {							% tin bin in
			dup 2 index exch get	% tin bin in count
			1 add					% tin bin in count+1
			2 index 3 1 roll put	% tin bin
		} ifelse					% tin bin
	} forall						% tin bin

	% Update each edge according to tin and bin
	edges {							% tin bin edge
		dup edgein 					% tin bin edge in top? 
		{							% tin bin edge in
			3 index exch get 1 gt {	% tin bin edge 
				dup 7 true put
			} if
		} {
			2 index exch get 1 gt {
				dup 7 true put
			} if
		} ifelse					% tin bin edge
		pop	
	} forall						% tin bin

	% Record edge label widths in widths
	edges {							% tin bin edge
		dup edgein pop 				% tin bin edge in
		1 index 7 get not {			% tin bin edge in
			exch 2 get				% tin bin in lbl
			stringwidth pop			% tin bin in w
			widths dup 3 index get	% tin bin in w widths wmax
			3 -1 roll max			% tin bin in widths wmax'
			exch 3 1 roll put		% tin bin
		} {
			pop pop
		} ifelse
	} forall

	% Clean up stack
	pop pop

	% Compute string widths
	/X 0 def
	widths words
	0 1 words length 1 sub {		% widths words i
		dup 3 index exch get		% widths words i wl
		exch 2 index exch get		% widths words wl word
		dup 0 get					% widths words wl word w
		3 -1 roll max				% widths words word wmax
		exch 0 X put				% widths words wmax
		X add dW add /X exch def	% widths words word
	} for
	/X X dW sub def
} def

/edgein % edge => in-node top? 
{	% Find in-node
	dup 1 get dup 0 lt {			% edge ±wmax
		abs 
	} {
		pop dup 0 get	
	} ifelse						% edge in

	% Find top/bottom
	exch 4 get 0 gt
} def 

% Layout words
/layout_arcs {
	% 1. Sort edges according to minimum and maximum word
	sort_edges 

	% 2. Compute edge label centering and word widths
	center_edge_label

	% 3. Compute edge heights for top and bottom edges
	{   } edge_heights
	{neg} edge_heights

	% 4. Compute edge displacements for top and bottom edges
	0 1 edges length 1 sub {
		edges exch get 4 0 put
	} for
	edge_displace

	% 5. compute /lines array 
	split_lines
} def

% print_line: iline => -
/print_line {								% l
	% Compute line height
	dup lines exch get 						% l L
	dup line_height							% l L height

	% Compute x0, y0, width and height
	1 index 2 get							% l L h x0
	dup 4 index 1 add lines exch get 2 get	% l L h x0 x0 x1
	exch sub 3 1 roll llx exch sub			% l L w h dx
	3 index 3 get ury exch sub				% l L w h dx y0
	
	% NOTE: abstract coordinates are translated (x,y) => (x+dx, y0-y)

	% Setup clipping path
	gsave 
	newpath llx 1 index moveto 3 index 0 rlineto
	0 3 index neg rlineto 3 index neg 0 rlineto 
	closepath 
	bggray 0 lt not {
		gsave bggray setgray fill grestore
	} if
	clip									% l L w h dx y0
	framegray 0 lt not {
		gsave framegray setgray stroke grestore 
	} if
	newpath
	4 2 roll pop pop						% l L dx y0

	% Draw word L[l].w0 to L[l+1].w0-1
	textfont setfontsize setupfont
	2 index 0 get 1							% l L dx y0 w0 1
	5 index 1 add lines exch get 0 get 1 sub% l L dx y0 w0 1 w1-1
	{										% l L dx y0 w
		print_word							% l L dx y0
	} for

	% Draw edges in L[l-1].cross
	smallfont setfontsize setupfont
	3 index 0 eq {
		[]									% l L dx y0 cross
	} {
		3 index 1 sub lines exch get 6 get	% l L dx y0 cross
	} ifelse
	{	print_edge							% l L dx y0
	} forall

	% Draw edge L[l-1].e0 to L[l].e0-1
	3 index 0 eq {
		0									% l L dx y0 e0
	} {
		3 index 1 sub lines exch get 1 get	% l L dx y0 e0
	} ifelse
	1 4 index 1 get 1 sub {					% l L dx y0 e
		print_edge							% l L dx y0
	} for									% l L dx y0

	% Restore clipping path and exit
	grestore
	pop pop pop pop
} def

% print_lines: 
/print_lines {
	0 1 lines length 2 sub {				% l
		% Print line
		dup print_line						% l

		% Execute showpage if next line has y = 0 
		1 add lines exch get 3 get 0 eq		% bool
		{	% Draw alignments (quick-and-dirty fix)
			alignments {
				aload pop align
			} forall

			% Showpage
			showpage
		} if
	} for
} def

% draw: - => -
/draw {
	currentdict /title known {llx titley moveto title {show} 0 format} if
	layout_arcs
	print_lines
} def

% setup: labels words edges => -
/setup {
	array /edges exch def
	dup array /words exch def
	array /widths exch def
	/nextw 0 def
	/nexte 0 def
	/strings exch def

	% Store (xc,ytop) coordinates for each word
	/xwords words length array def
	/ywords words length array def
	/nword 0 def
	/alignments [] def
} def


% Initialize fonts
true (ptm) /Times-Roman /Times-Bold /Times-Italic /Times-BoldItalic 
createfontfamily setfontfamily 
10 setfontsize 
0 setfontstyle
setupfont

%% Alignments

% align: aligntop alignbot => -
/align {
	% Draw alignbot							% aligntop alignbot
	dup type (arraytype) ne {
		% alignbot is a word index
		xyword moveto
	} {
		% alignbot is an array
		dup dup xmid exch 0 get xyword		% L xmid x[0] y[0]
		dA add exch pop 3 2 roll		% xc yc L
		{									% xc yc i
			xyword moveto					% xc yc xi yi
			2 copy lineto 					% xc yc
		} forall							% xc yc
		moveto								%
	} ifelse								
	
	% Draw aligntop							% aligntop
	dup type (arraytype) ne {
		% aligntop is a word index
		xyword topadjust lineto
	} {
		% aligntop is an array
		dup dup xmid exch 0 get xyword		% L xmid x[0] y[0]
		topadjust dA sub exch pop 		% L xc yc
		2 copy lineto 3 2 roll				% xc yc L
		{									% xc yc i
			xyword topadjust moveto					% xc yc xi yi
			2 copy lineto 					% xc yc
		} forall							% xc yc
		pop pop
	} ifelse

	% Stroke
	stroke
} def

% topadjust: 
/topadjust {strings dH mul sub 4 sub} def 

% xyword: word => x y
/xyword {
	dup xwords exch get
	exch ywords exch get
} def

% xmid: wordlist => xmid ymid
/xmid {
	dup 0 get xwords exch get	% L xmin
	exch dup length 1 sub get	% xmin imax
	xwords exch get				% xmin xmax
	add 2 div					% xmid
} def


%%EndPrologue

%% Begin graph description

% Specify the fonts used in the graph

	%% Helvetica (standard): uncomment the following two lines
	%true (phv) /Helvetica /Helvetica-Bold /Helvetica-Oblique
	%	/Helvetica-BoldOblique createfontfamily setfontfamily setupfont

	%% Times (standard): uncomment the following two lines
	%true (ptm) /Times-Roman /Times-Bold /Times-Italic /Times-BoldItalic 
	%	createfontfamily setfontfamily setupfont

	%% Courier (standard): uncomment the following two lines
	%true (pcr) /Courier /Courier-Bold /Courier-Oblique /Courier-BoldOblique
	%	createfontfamily setfontfamily setupfont


	%% AvantGarde (nonstandard): uncomment the following two lines
	%true (pag) /AvantGarde-Book /AvantGarde-BookOblique /AvantGarde-Demi
	% 	/AvantGarde-DemiOblique createfontfamily setfontfamily setupfont

	%% Bookman (nonstandard): uncomment the following two lines
	%true (pbk) /Bookman-Demi /Bookman-Light /Bookman-DemiItalic
	%	/Bookman-LightItalic createfontfamily setfontfamily setupfont

	%% Charter (nonstandard): uncomment the following two lines
	%true (bch) /Charter-Roman /Charter-Bold /Charter-Italic
	%	/Charter-BoldItalic createfontfamily setfontfamily setupfont

	%% GreekTimes (nonstandard): uncomment the following two lines
	%true (grk) /GreekTimesPlain /GreekTimesBold /GreekTimesItalic
	%	/GreekTimesBoldItalic createfontfamily setfontfamily setupfont

	%% Helvetica-Narrow (nonstandard): uncomment the following two lines
	%true (phvn) /Helvetica-Narrow /Helvetica-Narrow-Bold
	%	/Helvetica-Narrow-Oblique /Helvetica-Narrow-BoldOblique
	%	createfontfamily setfontfamily setupfont

	%% NewCenturySchlbk (nonstandard): uncomment the following two lines
	%true (pnc) /NewCenturySchlbk-Roman /NewCenturySchlbk-Bold 
	%	/NewCenturySchlbk-Italic /NewCenturySchlbk-BoldItalic
	%	createfontfamily setfontfamily setupfont

	%% Palatino (nonstandard): uncomment the following two lines
	%true (ppl) /Palatino-Roman /Palatino-Bold /Palatino-Italic
	%	/Palatino-BoldItalic createfontfamily setfontfamily setupfont

	%% TimesCyrMT (nonstandard): uncomment the following two lines
	%true (x) /TimesNRCyrMT /TimesNRCyrMT-Bold
	%	/TimesNRCyrMT-Inclined /TimesNRCyrMT-BoldInclined
	%	createfontfamily setfontfamily setupfont
	
	%% Utopia (nonstandard): uncomment the following two lines
	%true (put) /Utopia-Regular /Utopia-Bold /Utopia-Italic /Utopia-BoldItalic
	%	createfontfamily setfontfamily setupfont


% Specify the formats used in the graph by means of a list of
% PostScript procedures numbered from 1 to N that change the graphical
% state of PostScript (eg, foreground colour, background colour,
% dashes, fonts, etc.). The format 0 is interpreted as meaning the
% default format (black foreground, no dash, standard font size and face).

/formats [
	{0 1 0 setrgbcolor 1 setfontstyle setupfont 2 setlinewidth}
	{0.75 0.5 0 setrgbcolor 2 setfontstyle setupfont [2 3] 0 setdash}
	{0 0 1 setrgbcolor 3 setfontstyle setupfont}
	{1 0 0 setrgbcolor}
	{0 setlinewidth}
] def


% Specify number of labels, nodes, and edges in graph
%
%	syntax for specifying graph: 
%	
%		$labels $nodes $edges setup

3 21 18 setup
/title {(Dependency graph with alignments) 3} def

% Specify individual nodes and edges in graph (words are numbered from
% 0 to N in their order of appearance)
%
%	syntax for specifying word (arguments in squares are optional): 
%
%		$label1 [$format1] ... $labelN [$formatN] word
%
% 	syntax for specifying top edge (labelformat is used as arcformat,
% 	if no arcformat is specified): 
%
%		$inword $outword [$labelformat [$arcformat]] edget
%
% 	syntax for specifying bottom edge (labelformat is used as arcformat,
% 	if no arcformat is specified): 
%
%		$inword $outword [$labelformat [$arcformat]] edgeb
%

(Hvilket) (PT) (0) word
(ikke) (RG) (1) word
(ændrer) (VA) (2) word
(en) (PI) (3) word
(tøddel) (NC) (4) word
(ved) (SP) (5) word
(politiet) (NC) (6) word
(s) () (7) word
(opgave) (NC) (8) word
(\n) () () word

(Which) (PT) (10) word
(does) (VA) (11) word
(not) (RG) (12) word
(change) (VA) (13) word
(the) (PD) (14) word
(duties) (NC) (15) word
(of) (SP) (16) word
(the)  (PD) (17) word
(police) (NC) (18) word
(at) (SP) (19) word
(all) (RG) (20) word

% Alignments
/alignments [
	[0 10] 
	[1 12]
	[[2 5] [11 13]]
	[[3 4] [19 20]]
	[6 [17 18]]
	[7 16]
	[8 15]
] def

% Dependency edges
0 2 (subj) edget
1 2 (mod) edget
3 1 (mod) edget
4 3 (nobj) edget
5 2 (pobj) edget
6 7 (possr) edget
7 5 (nobj) edget
8 7 (possd) edget


10 11 (subj) edgeb
12 11 (mod) edgeb
13 11 (vobj) edgeb
14 13 (dobj) edgeb
15 14 (nobj) edgeb
16 14 (mod) edgeb
17 16 (nobj) edgeb
18 17 (nobj) edgeb
19 12 (mod) edgeb
20 19 (nobj) edgeb


%%BeginTrailer
% Draw
draw

% End 
end

%%EndTrailer
