%%BeginPrologue
%% DATA STRUCTURES:
%%     word = [x, string1, format1, ..., stringS, formatS]
%%     edge = [wmin, +/-wmax, label, height, dx, labelformat, arcformat, cent]
%%     fixedge = [wmin, +/-wmax, label, height, dx, labelformat, arcformat, cent, +/-width2, width1, fpass2, fpass1, barformat]
%%     line = [w0 e0 x0 y0 maxht maxhb [cross1 cross2 ...] dy]
%%     segment = [w1 w2 height edge1 ... edgeN]
%%
%% FORMATTING:
%%		edge: color, linewidth, dash
%%		label: color, bgcolor, roman/bold/italic/bolditalic
%%		elabel: color, bgcolor, roman/bold/italic/bolditalic

100 dict begin

% Parameters
/llx 20 def			% X-coordinate of lower left corner
/lly 20 def			% Y-coordinate of lower left corner
/urx 500 def 		% X-coordinate of lower left corner
/ury 810 def		% Y-coordinate of lower left corner
/titley 820 def		% Y-coordinate of title
/clipdx2 10 def

/LW 1 def			% line width
/X 2 def			% Current X-coordinate
/Y 0 def			% Current Y-coordinate

/dO 5 def			% arrow displacement
/dAs 1 def			% scale factor for arcs
/dA 10 def			% unit height of arc
/dAW 2.5 def		% arc head width
/dAH 6 def			% arc head height
%/dAD 2 def			% arc displacement
%/dAloop1 dAW 2 mul def % arc loops: left displacement initial curve point
%/dAloop2 dAW 4 mul def % arc loops: left displacement first control point

/dT 15 def 			% top edge label height
/dB 18 def 			% bottom edge label height
/dT0 12 def			% top edge label offset from bottom line
/dB0 8 def			% bottom edge label offset from bottom line
/dW 0 def			% word-word distance (fixed offset)
/dWr 0.5 def		% word-word distance (relative offset wrt. font size)
/dH 10 def			% unit height of single label line
/dL 20 def			% vertical distance between entire lines
/center false def	% center edge labels at the middle of each edge by default

/dEA 6 def			% fixation edge: unit height of fixation level
/dET0 3 def			% fixation edge: vertical offset from top 
/dEB0 -7 def			% fixation edge: vertical offset from bottom 
/dEsw 1 def			% fixation edge: fixation bar width scaling factor
/dEow 0 def			% fixation edge: fixation bar width offset
/dElw 2.5 def		% fixation edge: line width multiplier for fixation bar
/dElwa 0.3 def		% fixation edge: line width multiplier for connecting arc
/Emaxht 0 def		% the maximal height of top fixations
/Emaxhb 0 def		% the maximal height of bottom fixations
/EmaxhtMax 5 def	% never reserve space for more than 4 fixations on one word
/EmaxhbMax 5 def	% never reserve space for more than 4 fixations on one word
/dEah 4 def			% additional midpoint height in nearly-horizontal arcs
/dEaw 0.3 def		% width control point for nearly-horizontal arcs
/dEmaxw 200 def		% threshold width for 1-/2- dimensional edges

/strings 1 def		% number of strings in label
/framegray -1 def	% gray level of frame around lines
/bggray -1 def		% gray level of graph background
/smallfont 7 def
/textfont 10 def

/charstroke smallfont 0.4 mul def
/dy_lbl smallfont -0.3 mul def

/nextw 0 def
/nexte 0 def

% Initialize
LW setlinewidth

% Functions
/xdef {
	exch def
} def


% max: num1 num2 => max
/max {
    dup 3 -1 roll dup 3 -1 roll lt {pop} {exch pop} ifelse
} def


% min: num1 num2 => min
/min {
    dup 3 -1 roll dup 3 -1 roll gt {pop} {exch pop} ifelse
} def


%% Font setup
% Convert font to ISO-Latin1 encoded font
/ISOfont % font ISOfont
{   findfont
    dup length dict begin
       {1 index /FID ne {def} {pop pop} ifelse} forall
       /Encoding ISOLatin1Encoding def
       currentdict
    end
    definefont pop
} def

/setfontfamily {/fontfamily xdef} def
/setfontsize {/fontsize xdef} def
/setfontstyle {/fontstyle xdef} def
/setarrowtype {/arrowtype xdef} def
/font 7 string def
/fontext 4 string def
/setupfont
    {   font 0 fontfamily 0 get putinterval
        font 3 fontstyle 1 add 1000 mul fontsize cvi add
        fontext cvs putinterval
        currentdict font cvn known not
            {   currentdict font cvn fontfamily fontstyle 1 add get
                    findfont fontsize scalefont put
            } if
        font cvn cvx exec setfont
    } def

% setupfonts: iso? ext romanfont boldfont italicfont bolditalicfont
/createfontfamily {
	5 array astore exch					% fontfamily iso?
	{	% Generate ISO encodings		% fontfamily
		dup dup 1 get /Palatino-Roman-isolatin1 
			dup 3 1 roll exch ISOfont 1 exch put
		dup dup 2 get /Palatino-Bold-isolatin1 
			dup 3 1 roll exch ISOfont 2 exch put
		dup dup 3 get /Palatino-Italic-isolatin1 
			dup 3 1 roll exch ISOfont 3 exch put
		dup dup 4 get /Palatino-BoldItalic-isolatin1 
			dup 3 1 roll exch ISOfont 4 exch put
	} if
} def

% qsort: array cmp_proc => sorted
/qsort {
	1 index length 0 exch 							% array cmp 0 n
	qsortx pop
} def


% qsortx: array cmp_proc start stop => subsorted cmp
/qsortx {										
	% Subarray is sorted if r-l < 2
	2 copy 2 sub gt {								% array cmp l r
		% Subarray is sorted
		pop pop										% array cmp
	} {												% array cmp l r
		% Find pivot value and exit if -1
		findpivot									% array cmp l r ipivot
		dup -1 eq {
			% All values in array are identical, hence sorted
			pop pop pop								% array cmp
		} {
			% Find pivot value
			4 index exch get 3 1 roll				% array cmp ap l r
			2 copy 7 2 roll 1 sub					% l r array cmp ap l1 r1
									
			% Split subarray into two around pivot
			{	% Move left cursor over any elements < pivot
				exch								% array cmp ap r1 l1
				{	
					dup 5 index exch get 3 index	% array cmp ap r1 l1 al1 ap
					5 index exec 					% array cmp ap r1 l1 <=>
					-1 eq {1 add} {exit} ifelse		% array cmp ap r1 l1
				} loop
				exch

				% Move right cursor over any elements >= pivot
				{	dup 5 index exch get 3 index	% array cmp ap l1 r1 v ap
					5 index exec 					% array cmp ap l1 r1 <=>
					-1 gt {1 sub} {exit} ifelse		% array cmp ap l1 r1
				} loop

				% Exit if l > r
				2 copy gt {exit} if					% array cmp ap l1 r1

				% Switch elements pointed to by l and r, and repeat
				2 copy 6 index 3 1 roll switch		% array cmp pivot l1 r1
			} loop
			3 -1 roll pop pop 						% l r array cmp k

			% Sort two subarrays recursively
			5 -1 roll exch dup 6 1 roll				% k r array cmp l k
			qsortx									% k r array cmp
			4 2 roll qsortx							% array cmp
		} ifelse
	} ifelse
} def


% findpivot: array cmp l r => array cmp l r pi (array must have length>1)
/findpivot {
	% Find middle index and value
	2 copy add 1 sub 2 idiv							% A cmp l r m
	4 index 1 index get								% A cmp l r m am

	% For i:=m to m+(r-l), until am != ai
	1 index 1 1 index 5 index add 6 index sub 1 sub
													% A cmp l r m am m+1 1 m+r-l
	{ 												% A cmp l r m am i
		% Subtract r-l if i>=r
		dup 4 index ge {
			4 index add 3 index sub					
		} if										% A cmp l r m am i

		% Exit if am != ai
		dup 7 index	exch get 2 index				% A cmp l r m am i ai am
		7 index exec dup 0 ne {						% A cmp l r m am i <=>
			1 eq {									% A cmp l r m am i
				% Return i := i and set m := -1
				3 -1 roll pop -1 3 1 roll 			% A cmp l r -1 am i
				exit
			} {										% A cmp l r m am i
				% Return i := m and set m := -1
				pop -1 3 1 roll exch				% A cmp l r -1 am m
				exit
			} ifelse
		} {
			pop pop									% A cmp l r m am
		} ifelse
	} for

	% This procedure returns: "A cmp l r -1 am i" OR "A cmp l r m am"

	% Return -1 if m != -1, else i
	2 index -1 eq {									% A cmp l r -1 am i
		3 1 roll pop pop 							% A cmp l r i
	} {												% A cmp l r m am
		pop pop -1									% A cmp l r -1
	} ifelse
} def


% switch: array i j => -
/switch {
	2 index 2 index	get								% A i j ai
	3 index 2 index get								% A i j ai aj
	4 index	exch 6 1 roll 3 1 roll					% aj A i A j ai
	put 											% aj A i
	3 -1 roll put
} def


% intcmp: a b => sign(a-b)
/intcmp {
    2 copy lt {
        pop pop -1
    } {
        eq {0} {1} ifelse
    } ifelse
} def

% format: format procedure type => -
/format {
	% Process format type (0=word, 1=arclabel, 2=arc)
	pop 
	
	% Save graphical state (including fonts)
	gsave
	/oldfontstyle fontstyle def
	/oldfontsize fontsize def
	/oldfontfamily fontfamily def
	/oldarrowtype arrowtype def
	/olddAs dAs def
	exch

	% Change format, if unequal to last format and in 0...formats
	dup 0 ge							% format bool
	1 index formats length le and		% format bool
	{
		% Retrieve format
		dup 0 eq {
			% Format = 0: do nothing
			pop
		} {
			% Format > 0: execute formatting commands
			formats exch 1 sub get exec
		} ifelse
	} {
		pop
	} ifelse

	% Execute procedure
	exec

	% Restore graphics state and font
	grestore
	/dAs olddAs def
	oldarrowtype setarrowtype
	fontstyle oldfontstyle ne 
		fontsize oldfontsize ne or
		fontfamily oldfontfamily ne or
	{
		oldfontfamily setfontfamily 
		oldfontsize	setfontsize 
		oldfontstyle setfontstyle
		setupfont	
	} if
} def

% Arrows 
/arrowlbl % xi y0 xo dy lbl				
{	5 1 roll						% lbl xi y0 xo dy
	dA mul 2 index add 	 			% lbl x0 y0 x1 y1

	% Draw centered label
	5 -1 roll 						% x0 y0 x1 y1 lbl
	4 index	3 index add 2 div		% x0 y0 x1 y1 lbl xc
	2 index 5 index sub 0.75 mul 	% x0 y0 x1 y1 lbl xc yc'
	5 index add						% x0 y0 x1 y1 lbl xc yc
	moveto							% x0 y0 x1 y1 lbl
									% (stringwidth: within scope of format)
	dup stringwidth pop -2 div	 	% x0 y0 x1 y1 lbl -w/2
	dy_lbl							% x0 y0 x1 y1 lbl -w/2 dy
	rmoveto							% x0 y0 x1 y1 lbl

	% Left displacement for with loops
	4 index 3 index sub abs dO 1.05 mul lt {
		dO neg 1.5 mul 0 rmoveto
	} if

	% Print outline first in white, then print the real thing
	0 currentlinewidth eq {
		pop
	} {
		gsave
			dup 0 setlinecap [] 0 setdash true charpath charstroke 
			setlinewidth 1 setgray stroke
		grestore
		show							% x0 y0 x1 y1
	} ifelse

	% Clean up stack
	pop pop pop pop					% -
} def


/arrow % xi y0 xo dy 
{	% Check for special case: xi = xo
	3 index 2 index sub abs dO 1.05 mul lt {					% xi y0 xo dy
		% Special case: xi = xo
		dA mul 0.75 mul 2 index add 	 				% x0 y0 x1 y1
		4 -1 roll 15 sub 4 1 roll
		matrix currentmatrix				% x0 y0 x1 y1 M
		4 index 3 index add 2 div 4 index	% x0 y0 x1 y1 M xc y0
		translate							% x0 y0 x1 y1 M
		4 index 3 index sub 2 div abs 		% x0 y0 x1 y1 M xr
		4 index 3 index sub					% x0 y0 x1 y1 M xr yr
		scale								% x0 y0 x1 y1 M
		newpath
		0 0 1 180 360 arc						% x0 y0 x1 y1 M
		setmatrix
		currentlinewidth 0 eq 
			{newpath} {stroke} ifelse		% x0 y0 x1 y1
	} {										% xi y0 xo dy
		% Normal case: xi != xo
		dA mul 2 index add 	 				% x0 y0 x1 y1

		% Draw arrow curve from x1 to x0
		4 copy 								% ... x0 y0 x1 y1
		exch 2 copy							% ... x0 y0 y1 x1 y1 x1
		5 index 5 1 roll 5 index			% ... x0 y0 x0 y1 x1 y1 x1 y0
		8 -2 roll moveto					% ... x0 y1 x1 y1 x1 y0
		curveto								% ...
		currentlinewidth 0 eq 
			{newpath} {stroke} ifelse		% x0 y0 x1 y1
	} ifelse

	% Draw arrow-head
	2 index	gt {-1} {1} ifelse dAH dAs mul mul	% x0 y0 x1 dh
	3 1 roll exch						% x0 dh x1 y0
	moveto dAW dAs mul 0 rmoveto				% x0 dh
	dAW dAs mul -2 mul 0 rlineto
	dAW dAs mul exch rlineto pop				% 
	closepath 
	currentlinewidth 0 eq
		{newpath} {fill} ifelse		
} def 


% word: s1 [format1] ... sS [formatS] => [w, s1, format1, ... sS, formatS]
/word {
	% Create array
	strings 2 mul 1 add array			% s1... W
	strings -1 1 {						% s1... W I
		% Extract label and format
		2 index type /integertype eq {	% s1... sI formatI W I
			4 2 roll					% s1... W I sI formatI
		} {								% s1... sI W I
			3 -1 roll 0					% s1... W I sI formatI
		} ifelse						% s1... W I sI formatI

		% Save label and format
		3 index 3 index 2 mul 3 -1 roll % s1... W I sI W 2I formatI
		put								% s1... W I sI
		2 index	2 index 2 mul 1 sub 	% s1... W I sI W 2I-1
		3 -1 roll 						% s1... W I W 2I-1 sI
		put pop							% s1... W
	} for								% W

	% Find maximal width of all strings and store in widths array
	0 1 1 strings { 					% W wmax I
		2 index exch 2 mul dup 1 sub 2 index exch get 3 1 roll get 
										% W wmax sI formatI
		{stringwidth} 0 format			%
		pop				 				% W wmax swidth
		max								% W wmax 
	} for								% W wmax
	widths nextw 3 -1 roll put			% W
	dup 0 0 put							% W

	% Store word
	currentdict /words known {words nextw 3 -1 roll put} if
	/nextw nextw 1 add def
} def

% newedge: imin imax label [lblformat [arcformat]] => edge
/newedge {
	% Ensure formats are specified
	dup type /stringtype eq {			% imin imax label
		0 0								% imin imax label lfmt afmt
	} {										
		1 index type /stringtype eq {	% imin imax label lfmt
			dup							% imin imax label lfmt afmt
		} if							% imin imax label lfmt afmt
	} ifelse							% imin imax label lfmt afmt
	5 2 roll 							% lfmt afmt imin imax label

	% Calculate wmin, wmax, label
	3 1 roll 2 copy gt {exch neg} if 	% lfmt afmt label wmin wmax
	3 -1 roll 0 1						% lfmt afmt wmin wmax label height dx
	7 -2 roll							% wmin wmax label height dx lfmt afmt
	center 8 array astore
} def

% edget: imin imax label [lblformat [arcformat]] => edge
/edget {
	% Create edge object
	newedge

	% Store edge
	currentdict /edges known {edges nexte 3 -1 roll put} if
	/nexte nexte 1 add def
} def


% edgeb: imin imax label [lblformat [arcformat]] => edge
/edgeb {
	% Create edge object
	newedge
	dup 4 -1 put

	% Store edge
	currentdict /edges known {edges nexte 3 -1 roll put} if
	/nexte nexte 1 add def
} def

% eedget: ... pass width
/eedget {
	/barstyle xdef
	/fixpass1 xdef
	/fixpass2 xdef
	/fixwidth1 xdef
	/fixwidth2 xdef

	% Create edge object
	newedge
	fixedge

	% Store edge
	currentdict /edges known {edges nexte 3 -1 roll put} if
	/nexte nexte 1 add def
} def

/eedgeb {
	/barstyle xdef
	/fixpass1 xdef
	/fixpass2 xdef
	/fixwidth1 xdef
	/fixwidth2 xdef

	% Create edge object
	newedge dup 4 -1 put 
	fixedge

	% Store edge
	currentdict /edges known {edges nexte 3 -1 roll put} if
	/nexte nexte 1 add def
} def

/fixedge {						% edge 
	[ exch aload pop fixwidth2 4 index 0 lt {neg} if fixwidth1 fixpass2 fixpass1 barstyle]
		% epos newedge 
	dup 4 0 put
} def

% xcenter: i => xcenter
/xcenter {
	% Unload word and compute xcenter
	dup words exch get 0 get exch 		% x0 i
    1 add dup words length eq           % x0 i1 bool
        {pop X} 
		{words exch get 0 get} ifelse   % x0 x1
	%dW sub 
	add 2 div							% xcenter
} def

% Segment data structure:
%
% 	segment = [w1-w2|height|wf1,wf2,...,wfN]
%
%		w1=start word
%		w2=end word   (w2>w1)
%		wfi=end word of edge w1-wfi with wfi>w1
%		height=height of all edges between w1 and w2, excluding edges 
%			wf1,...,wfN
%
% Segments are placed on a stack. Reductions:
%
%	1. [w1-w2|h1|E] + [w3-w4|h2|], w2>=w3 => [w1-w4|max(h1,h2)|E]
%   2. [w1-w2|h|w2,E] => [w1-w2|h+1|E]
%	3. [w1-w2|h1|E1] + ([w3-w4|h2|E2]), w1<=w3<=w2<w4 => [w1-w2|max(h1,h2)|E1]
%		then reduce rest of stack with 1-3
%	4. => [i-(i+1)|0|forward-edges(i)]

% edge_heights: - => -
%	s0 ... sN sign nextword nextedge N continue
/edge_heights {
	% Initialize
	[ exch 0 0 0 							% [ sgn nw ne N 

	% Reduce stack
	edge_heights0							% [ s0 ... sN sgn nw ne N

	% Empty stack
	{pop} repeat pop pop pop pop
} def


/edge_heights0 {
	% Reduce stack
	{										% s0 ... sN sgn nw ne N
		% Perform edge_height operations until one succeeds
		edge_heights1
		{true} {edge_heights2} ifelse
		{true} {edge_heights3} ifelse
		{true} {edge_heights4} ifelse

		% Stop computation if no operation succeeded
		not {exit} if
	} loop									% s0 ... sN sgn nw ne N
} def

% edge_heights1: s0...sN sgn nw ne N => s0...sM sgn nw ne M cont
/edge_heights1 {
	% Check whether N>1 and top segment is completed
	dup 2 lt {								% s0...sM sgn nw ne N
		false								
	} {
		4 index length 3 eq {				% s0...sM sgn nw ne N 
			% Top segment has no edges
			true
		} {									% s0...sM sgn nw ne N
			% Succeed if top segment has an edge
			4 index 3 get -1 eq 
		} ifelse							% s0...sM sgn nw ne N cont
	} ifelse

	% Join two top segments if cont=true
	{										% ...sM1 sM sgn nw ne N 
		5 -1 roll dup						% ...sM1 sgn nw ne N sM sM
		1 get exch 2 get					% ...sM1 sgn nw ne N sMw1 sMh
		6 index	dup	dup 					% ... sMw1 sMh sM1 sM1 sM1

		% Update maxh
		2 get 4 -1 roll	max	2 exch put		% ... sMw1 sM1 

		% Update w1
		1 3 -1 roll put 1 sub true			% ... N1 true
	} {false} ifelse
} def

% edge_heights2:
/edge_heights2 {							% s0...sM sgn nw ne N
	% Check that N > 0
	dup 0 gt {
		4 index length 3 gt {
			% Top segment contains an edge
			4 index 3 get -1 ne {
				% Edge is undeleted
				4 index dup dup					% ... sM sM sM
				1 get exch 3 get				% ... sM w1 e
				edges exch get 1 get abs		% ... sM w1 w1'
				eq {							% ... sM
					% Increase height
					dup dup 					% ... sM sM sM
					2 get 1 add 2 exch dup 		% ... sM sM 2 maxh maxh
					4 1 roll put				% ... sM maxh

					% Save height in edge
					1 index 3 get 				% ... sM maxh e
					edges exch get				% ... sM maxh edge
					3 3 -1 roll 				% ... sM edge 3 maxh
					7 index exec put			% ... sM

					% Rotate edges
					mark exch dup				% ... [ sM sM
					aload pop					% ... [ sM w0 w1 maxh e1...eN
					counttomark 4 sub -1 roll	% ... [ sM w0 w1 maxh e2...eN e1
					pop -1 						% ... [ sM w0 w1 maxh e2...eN -1
					counttomark -1 roll			% ... [ w0 w1 maxh e2...eN -1 sM
					astore pop pop				% ...
					true						% s0...sM sgn nw ne N true
				} {
					% w1 != w1'
					pop false					% s0...sM sgn nw ne N false
				} ifelse
			} {
				% Edge is deleted 
				false
			} ifelse
		} {
			% Top segment has no edges
			false
		} ifelse
	} { 
		false
	} ifelse
} def

%	3. [w1-w2|h1|E1] + ([w3-w4|h2|E2]), w1<=w3<=w2<w4 => [w1-w4|max(h1,h2)|E1]
%		then reduce rest of stack with 1-3
% edge_heights3:
/edge_heights3 {						% s1...sN sgn nw ne N 
	% Check that N>1
	dup 1 gt {
		% Check that 2nd segment ends before 1st segment
		5 index 5 index					% s1...sN sgn nw ne N sN1 sN
		dup 1 get exch 2 get			% s1...sN sgn nw ne N sN1 sNw1 sNh
		3 -1 roll 1 get					% s1...sN sgn nw ne N sNw1 sNh sN1w1
		2 index ne {					% s1...sN sgn nw ne N sNw1 sNh
			% Segments do not end in same place: combine sN-1 and sN
			7 index dup 				% s1...sN sgn nw ne N sNw1 sNh sN1 sN1
			1 5 -1 roll put				% s1...sN sgn nw ne N sNh sN1	
			dup 2 get 3 -1 roll max		% s1...sN sgn nw ne N sN1 sN1h'
			2 exch put					% s1...sN sgn nw ne N

			% Pop off sN (store before bottom of stack)
			5 -1 roll					% s1...sN1 sgn nw ne N sN
			1 index 4 add 1 roll 1 sub	% sN s1...sN1 sgn nw ne N-1
			
			% Reduce stack
			edge_heights0				% sN s1...sN' sgn nw ne N'

			% Restore sN				% sN s1...sN1 sgn nw ne N-1
			1 add dup 4 add -1 roll		% s1...sN1 sgn nw ne N sN
			5 1 roll					% s1...sN sgn nw ne N

			% Return true
			true
		} {
			pop pop false
		} ifelse
	} { 
		false
	} ifelse
} def

% edge_heights4: s0...sN-1 sgn nw ne N => s0...sN sgn nw ne N cont
/edge_heights4 {
	% Check that we are not recursively reducing stack (ie, distance
	% to mark is N+4)
	counttomark 1 index 4 add eq {
		% Check that nw does not exceed number of words
		2 index words length lt {
			% Read next word
			mark 3 index dup 0				% sgn nw ne N [ w0 w1 0
			7 index	6 index					% sgn nw ne N [ w0 w1 0 sgn ne

			% Read edges starting at w0
			{	% Exit if ne>#edges			% ... [...w0 w1 0 sgn ne
				dup edges length ge {
					exch pop exit			% ... [...w0 w1 0 ne
				} if

				% Read next edge, and exit if edge[ne].0 != w0
				dup edges exch get dup 0 get% ... [...w0 w1 0 sgn ne e ew0
				6 index eq {				% ... [...w0 w1 0 sgn ne e
					4 get 2 index exec 0 gt{% ... [...w0 w1 0 sgn ne 
						dup 6 1 roll 		% ... [...ne w0 w1 0 sgn ne
					} if 
					1 add					% ... [...ne w0 w1 0 ne+1
				} {							% ... [...w0 w1 0 sgn ne e
					pop exch pop exit		% ... [...w0 w1 0 ne 
				} ifelse
			} loop							% sgn nw* ne* N [e1...eM w0 w1 0 ne

			% Close segment and update nw and ne
			counttomark 1 add 1 roll		% sgn nw* ne* N ne [e1...eM w0 w1 0
			counttomark 3 roll ]			% sgn nw* ne* N ne [w0 w1 0 e1...eM]
			6 1 roll						% sN sgn nw* ne* N ne

			3 1 roll 1 add exch pop			% sN sgn nw* ne N+1
			3 -1 roll 1 add 3 1 roll true	% sN sgn nw ne N+1 true
		} {
			false							% sgn nw ne N false
		} ifelse
	} {
		false
	} ifelse
} def

% Edge displacement
/edge_displace {
	% wordt wordb word nemin nemax 
	-1 -1 0 0 0

	% Process each word
	{	
		% Exit if current word does not exist
		2 index words length ge {				% wt wb w en ex
			pop pop pop pop pop exit
		} if
		
		% Update wordt and wordb for current word
		5 -2 roll pop pop -1 -1 5 2 roll		% -1 -1 w en ex
		1 index edges 0	3 -1 roll update_super	% wt wb w en ex
		dup maxedges 1 3 -1 roll update_super	% wt wb w en ex

		% Assign displacements to out-edges from w
		exch edges 0 3 -1 roll displace exch	% wt wb w en' ex
		maxedges 1 3 -1 roll displace			% wt wb w en ex'

		% Increment word
		3 -1 roll 1 add 3 1 roll				% wt wb w' en ex
	} loop
} def

% displace: wt wb w * edges i e => wt wb w * e'
/displace {
	{	% Exit if e >= #E						
		dup 3 index length ge {					% wt wb w * E i e
			3 1 roll pop pop exit				% wt wb w * e
		} if									% wt wb w * E i e

		% Exit if E[e].i > w
		2 index 1 index get						% wt wb w * E i e edge
		dup 3 index get abs						% wt wb w * E i e edge wi
		6 index gt {							% wt wb w * E i e edge
			pop 3 1 roll pop pop exit			% wt wb w * e
		} if									% wt wb w * E i e edge
		
		% Check that edge points to w
		dup ioword 								% wt wb w * E i e edge wi wo
		7 index eq {							% wt wb w * E i e edge wi
			% Check top/bottom edge
			1 index 3 get 0 gt {				% wt wb w * E i e edge wi
				% Top edge
				8 index
			} {
				% Bottom edge
				7 index
			} ifelse							% ... edge wi wtb

			% Assign offset
			dup -1 eq {							% ... edge wi wtb
				% No in-edge for w 
				pop pop 4 0 put					% ...
			} {	
				% w has in-edge from wtb (-1 = sign if in-between wtb and w)
				7 index -1						% ... edge wi wtb w sgn

				% Order wtb<w, inverting sign if necessary
				2 index 2 index gt {			% ... edge wi wtb w sgn
					% wtb > w
					neg exch 3 1 roll			% ... edge wi w wtb -sgn
				} if							% ... edge wi w1 w2 sgn
				4 1 roll						% ... edge sgn wi w1 w2

				% Check whether wi is between w1 and w2
				2 index gt 3 1 roll gt and not {% ... edge sgn
					% Not in-between: negate sign
					neg
				} if

				% Store sign
				4 exch put						% ...
			} ifelse
		} {										% wt wb w * E i e edge wi
			pop pop								% wt wb w * E i e
		} ifelse

		% Increment e
		1 add
	} loop
} def

% update_super: wt wb w en ex edges i e => wt wb w en ex
/update_super {									% wt wb w en ex edges i e
	% Look forward in E to update wordt and wordb
	{	
		% Exit if e >= #E						% wt wb w en ex E i e
		dup 3 index length ge {					% wt wb w en ex E i e
			pop pop pop exit					% wt wb w en ex
		} if									% wt wb w en ex E i e

		% Exit if E[e].i > w
		2 index 1 index get						% wt wb w en ex E i e edge
		dup 3 index get 						% wt wb w en ex E i e edge wi
		7 index gt {							% wt wb w en ex E i e edge
			pop pop pop pop exit				% wt wb w en ex
		} if									% wt wb w en ex E i e edge
		
		% Check that in-word = w
		dup ioword exch							% wt wb w en ex E i e edge wo wi
		8 index eq {							% wt wb w en ex E i e edge wo
			% Update wt and wb
			exch 3 get							% wt wb w en ex E i e wo h
			0 gt {								% wt wb w en ex E i e wo
				% Replace wt with wo
				9 -1 roll pop 8 1 roll			% wo wb w en ex E i e
			} {
				% Replace wb with wo
				8 -1 roll pop 7 1 roll			% wt wo w en ex E i e
			} ifelse
		} {
			pop pop
		} ifelse								% wt wb w en ex E i e

		% Increase edge
		1 add									% wt wb w en ex E i e+1
	} loop										% 
} def 

% edge => in out
/ioword {										% edge
	dup 0 get exch 1 get 						% w0 w1
	dup 0 lt {									% w0 w1
		abs exch 								% wi wo
	} {
		abs 									% wi wo
	} ifelse
} def


% split_lines: - => -
/split_lines {
	% Process words (w0 x0): split words into lines until no words left
	split_words

	% Process edges (e0 maxht maxhb cross): compute edge boundaries,
	% maximal heights and cross edges
	split_edges

	% Place lines on pages (y0)
	split_pages
} def

% split_words: - => -
/split_words {
	/lines [
	urx llx sub 0 0 1 							% maxw x0 i0 i
	{	% Read lines until no words left (ie, i0>=#words)
		1 index words length ge {				% maxw x0 i0 i
			pop pop pop pop 
			exit
		} if

		% Create next line object				% maxw x0 i0 i
		[2 index 0 5 index 0 0 0 0 0] 5 1 roll	% line maxw x0 i0 i

		% Read next line
		{	% Read mw width words				% maxw x0 i0 i 
			dup xpos 							% maxw x0 i0 i xi
			1 index words length ge {
				dup								% maxw x0 i0 i xi xi
			} {
				1 index 1 add xpos				% maxw x0 i0 i xi x[i+1]
			} ifelse
			4 index sub							% maxw x0 i0 i xi width

			% Exit if width > maxwidth or i>#W
			5 index gt 							% maxw x0 i0 i xi bool
			2 index newline or					% maxw x0 i0 i xi bool
			2 index words length ge or {		% maxw x0 i0 i xi 
				exch 4 2 roll pop pop dup 1 add	% maxw xi i i+1
				exit
			} if								% maxw x0 i0 i xi

			% Increment i
			pop	1 add							% maxw x0 i0 i
		} loop
	} loop										% 
	[words length edges length X 0 0 0 0 0]
	] def
} def

/split_edges {
	% Process edges: compute e0, maxht, maxhb and cross-edges
	0 [] 										% e0 cross
	0 1 lines length 2 sub {					% e0 C il

		% Initialize parameters
		dup 1 add lines exch get 0 get exch		% e0 C w1 il
		lines exch get 0 0 						% e0 C w1 L hmn hmx
		2 index [ 8 2 roll						% L [ e0 C w1 L hmn hmx

		% Copy edges in C with e.wmax>=w1
		4 index {								% .. e0 C w1 L hmn hmx e 

			% Add cross-edge to new cross-edges, if necessary
			dup edges exch get 1 get abs		% .. e0 C w1 L hmn hmx e e.wmax
			5 index ge {						% .. e0 C w1 L hmn hmx e
				dup 8 1 roll					% .. e e0 C w1 L hmn hmx e 
			} if								% .. e e0 C w1 L hmn hmx e

			% Update hmn and hmx
			edges exch get 3 get				% .. e0 C w1 L hmn hmx h
			dup 4 -1 roll min 3 1 roll max		% .. e0 C w1 L hmn' hmx'
		} forall								% [ ... e0 C w1 L hmn hmx

		% Process edges until e0.min>w1
		{
			% Exit if e0>=#edges				% ... e0 C w1 L hmn hmx
			5 index edges length ge {
				exit							% ... e0 C w1 L hmn hmx
			} if

			% Exit if e0.min>w1
			5 index edges exch get 0 get 		% ... e0 C w1 L hmn hmx e0.min
			4 index ge {						% ... e0 C w1 L hmn hmx
				exit							% ... e0 C w1 L hmn hmx
			} if

			% Add e0 to cross-edges if e0.wmax>=w1
			5 index edges exch get				% ... e0 C w1 L hmn hmx edge
			dup 1 get abs 5 index ge {			% ... e0 C w1 L hmn hmx edge
				6 index 7 1 roll				% ... e0 e0 C w1 L hmn hmx edge
			} if

			% Update hmn and hmx
			3 get dup 4 -1 roll min				% ... e0 C w1 L hmx h hmn'
			3 1 roll max						% ... e0 C w1 L hmn' hmx'

			% Increase e0
			6 -1 roll 1 add 6 1 roll			% ... e1
		} loop									% L [ ... e0 C w1 L hmn hmx

		% Update line L
		2 index 4 3 -1 roll put					% L [ ... e0 C w1 L hmn 
		1 index 5 3 -1 roll abs put				% L [ ... e0 C w1 L 
		3 1 roll pop pop 						% L [ ... e0 L
		1 2 index put							% L [ ... e0
		counttomark 1 add 1 roll ]				% L e0 [ ... ]
		2 index 6 2 index put 					% L e0 C1
		3 -1 roll 1 3 index put					% e0 C1
	} for										% e0 C1
	pop pop
} def

% split_pages: - => -
/split_pages {
	% Process lines
	0 ury lly sub 0 							% ya ymax y
	0 1 lines length 2 sub {					% ya ymax y l
		lines exch get							% ya ymax y L

		% Compute line height = (ht+hb)*dA + S*dH + dB + dT
		dup line_height							% ya ymax y L height

		% Reset y to 0 if y+height>ymax
		3 index 3 index 2 index add lt {		% ya ymax y L height
			3 -1 roll 5 -1 roll add				% ymax L height ya+y
			4 1 roll 0 3 1 roll					% ya+y ymax 0 L height
		} if

		% Store ya in line
		1 index 7 6 index put					% ya ymax y L height

		% Set line height to y and update y += height + dL
		exch 3 3 index put						% ya ymax y height
		add dL add								% ya ymax y
	} for
	pop pop pop
} def

% line_height: Line => height
/line_height {
	dup 4 get exch 5 get add dA mul			% (ht+hb)*dA
	strings dH mul add dB add dT add		% (ht+hb)*dA + S*dH + dB + dT
} def

% xpos: iword => xpos
/xpos {
	dup words length ge {						% i
		% Return X if i>=#Words
		pop X
	} {											% i
		words exch get 0 get
	} ifelse
} def

/newline {								% i
	1 sub
	dup words length ge 1 index 0 lt or {
		pop false
	} {
		words exch get 1 get (\n) eq 
	} ifelse
} def

% layout_word: L dx y0 w => L dx y0 i xc y
/layout_word {
	% Compute ypos = y0-(maxht*dA)-dT
	1 index 							% L dx y0 i y0
	4 index 4 get dA mul sub dT sub		% L dx y0 i y
	
	% Compute xcenter
	1 index xcenter						% L dx y0 i y xc
	4 index add exch					% L dx y0 i xc y

	% Save xcenter and y in /xwords and /ywords arrays
	xwords nword 3 index 
	put
	ywords nword 2 index 				% L dx y0 i xc y yws nw y
	8 index 7 get sub					%
	put			% L dx y0 i xc y
	/nword nword 1 add def

} def

% print_word: L dx y0 w => L dx y0
/print_word { 							% L dx y0 i
	layout_word

	% Print label l around (xc,y-(l+1)*dH)
	3 -1 roll words exch get			% L dx y0 xc y W
	1 1 strings {						% L dx y0 xc y W i
		3 -1 roll dH sub 3 1 roll		% L dx y0 xc y' W i
		2 copy 2 mul get 3 1 roll		% L dx y0 xc y' format W i 
		1 index exch 2 mul 1 sub get 	% L dx y0 xc y' format W str
		dup 3 index 
										% L dx y0 xc y' format W str str format
		{stringwidth} 0 format			% L dx y0 xc y' format W str w 0
		pop 2 div neg					% L dx y0 xc y' format W str -w/2
		5 index add 4 index moveto		% L dx y0 xc y' format W str 
		3 -1 roll 						% L dx y0 xc y' W str format
		{show} 0 format 				% L dx y0 xc y' W
	} for
	pop pop pop							% L dx y0 
} def

% print_edge: cnt L dx y0 e => L dx y0
/print_edge_cross {
	dup edges exch get length 8 gt {
		%pop
		edges exch get 
		print_fixation_edge
	} {
		print_edge
	} ifelse
} def

/print_edge {
	% Retrieve edge 
	edges exch get 									% cnt L dx y0 E
	dup length 8 gt {								
		% Fixation edge
		print_fixation_edge							% cnt L dx y0 E
	} {
		1 index										% cnt L dx y0 E y
		1 index 7 get 6 1 roll				% cnt E7 L dx y0 E y

		% Calculate y and yl for label
		4 index 4 get dA mul sub					% cnt E7 L dx y0 E y'
		1 index 3 get 0 ge {
			% Top edge
			dup dT0 sub 							% cnt E7 L dx y0 E y yl
		} { 
			% Bottom edge
			dT sub strings dH mul sub dB sub		% cnt E7 L dx y0 E y
			dup dB0 add								% cnt E7 L dx y0 E y yl
		} ifelse

		% Compute xcenters
		2 index ioword								% cnt E7 L dx y0 E y yl wi wo
		xcenter 6 index add 						% cnt E7 L dx y0 E y yl wi xo
		exch xcenter 6 index add					% cnt E7 L dx y0 E y yl xo xi

		% Print label above in-word
		dup 4 -1 roll moveto						% cnt E7 L dx y0 E y xo xi
		7 index not {
			3 index 2 get 							% cnt E7 L dx y0 E y xo xi lbl
			dup 5 index 5 get
			{stringwidth} 0 format 
			pop -2 div 0 rmoveto	% cnt L dx y0 E y xo xi lbl
			4 index 5 get {
				currentlinewidth 0 eq 
					{pop} {show} ifelse
			} 1 format 								% cnt L dx y0 E y xo xi
		} if

		% Print arrow
		exch 3 index 4 get dO mul add 3 1 roll		% cnt L dx y0 E xo' y xi
		3 index 3 get		 						% cnt L dx y0 E xo y xi h
		4 copy										% ... E xo y xi h xo y xi h
		8 index 6 get {arrow} 2 format				% cnt L dx y0 E xo y xi h

		% Print centered label
		8 index {
			4 index 2 get 							% cnt L dx y0 E xo y xi h lbl
			5 index 5 get {arrowlbl} 1 format		% cnt L dx y0 E
		} {
			pop pop pop pop							% cnt L dx y0 E
		} ifelse

		% Clean up stack
		pop	4 -1 roll pop							% L dx y0
	} ifelse
} def

/xylword {											% w L => x y
	7 get exch 										% y0 w
	xyword			 								% y0 x y
	3 -1 roll add
} def

%%[wmin, +/-wmax, label, height, dx, labelformat, arcformat, cent, +/-width2, width1, fpass2, fpass1]
/print_fixation_edge {							% cnt L dx y0 E
	% Find in and out words
	dup ioword									% cnt L dx y0 E Wi Wo

	% Calculate x,y positions for each node
	words 2 index get 0 get words 2 index get 0 get % cnt L dx y0 E Wi Wo xi xo
	sub abs dEmaxw lt {								% cnt L dx y0 E Wi Wo
		3 index 6 index 4 get dA mul sub dT sub	% cnt L dx y0 E Wi Wo y
		dup 3 index xcenter 7 index add
		3 index xcenter 8 index add		% cnt L dx y0 E Wi Wo y y xi xo
		4 1 roll exch							% cnt L dx y0 E Wi Wo xo y xi y
		6 -2 roll pop pop
	} {
		5 index xylword								% cnt L dx y0 E Wi xo yo
		3 -1 roll 6 index xylword					% cnt L dx y0 E xo yo xi yi
	} ifelse

	% Adjust y for each fixation bar
	4 index 10 get dEA mul						% ... E xo yo xi yi dyi
	5 index 11 get dEA mul						% ... E xo yo xi yi dyi dyo
	6 index 8 get 0 gt {						% ... E xo yo xi yi dyi dyo
		% Top fixation edge
		dET0 add exch 				% ... E xo yo xi yi dyo' dyi
		dET0 add exch					% ... E xo yo xi yi dyi' dyo'
	} {
		% Bottom fixation edge
		neg fixbotadjust dEB0 add exch 							% ... E xo yo xi yi dyo' dyi
		neg fixbotadjust dEB0 add exch							% ... E xo yo xi yi dyi' dyo'
	} ifelse
	5 -1 roll add 4 1 roll						% ... E xo yo+dyo' xi yi dyi' 
	add 										% ... E xo yo+dyo' xi yi+dyi' 

	% Calculate widths for each fixation bar 
	4 index 8 get abs dEsw mul dEow add			% cnt L dx y0 E xo yo' xi yi' wi
	5 index 9 get dEsw mul dEow add				% cnt L dx y0 E xo yo' xi yi' wi wo
	4 1 roll									% cnt L dx y0 E xo yo' wo xi yi' wi
	3 copy 9 index draw_fixation_bar			% ... y0 E xo yo wo xi yi wi
	6 index 10 index 
	1 index 6 get {draw_fixation_edge} 2 format			% cnt L dx y0 E
	%draw_fixation_edge			% cnt L dx y0 E

	% Clean up stack
	pop	
	%4 -1 roll pop								% L dx y0
} def

% draw_fixation_bar: x y w E => -
/draw_fixation_bar {
	gsave
	4 2 roll 0 sub moveto 						% w E
	gsave
	exch dup 2 div neg							% E w -w/2
	0 rmoveto 0 rlineto							% E
	currentlinewidth dElw mul setlinewidth		% E
	dup 5 get {stroke} 2 format				% E
	grestore
	0 -2 rmoveto
	dup 2 get exch 12 get {cshow} 2 format					%
	grestore
} def

/draw_fixation_bar {
	gsave
	4 2 roll 0 sub moveto 						% w E
	exch dup 2 div neg							% E w -w/2
	0 rmoveto 0 rlineto							% E
	currentlinewidth dElw mul setlinewidth		% E
	dup 5 get {stroke} 2 format				% E
	5 -2 rmoveto
	dup 2 get exch 12 get {cshow} 2 format					%
	grestore
} def


/cshow {					
	dup stringwidth pop 2 div neg 0 rmoveto 
	show
} def

/cshowbgfill {
	dup stringwidth pop 2 div neg 0 rmoveto 
	gsave
		dup 0 setlinecap [] 0 setdash true charpath charstroke 
		setlinewidth 1 setgray stroke
	grestore
	show			
} def

/draw_fixation_edge {							% xo yo wo xi yi wi E L
	exch 8 2 roll								% L E xo yo wo xi yi wi
	5 index 3 index eq 5 index 3 index eq and {
		% xo == xi and yo == yi					% L E xo yo wo xi yi wi
		pop pop pop pop pop pop pop pop
	} {
		% Find in- and out-points				% L E xo yo wo xi yi wi
		2 div 3 -1 roll exch sub exch			% L E xo yo wo xi' yi
		5 2 roll 2 div 3 -1 roll add exch		% L E xi' yi xo' yo

		% Forward edges drawn with curves, backward edges also with arcs
		gsave
		dup 3 index sub abs 50 lt 
		2 index 5 index ne and {				% L E xi yi xo yo
			% Place xo,yo at origin
			2 copy moveto
			3 -1 roll sub neg 					% .. xi xo yi-yo
			3 1 roll sub exch					% .. xi-xo yi-yo

			% Bow height
			dEah 3 index 8 get 0 le {neg} if
			3 1 roll
			%4 3 index 8 get gt {neg} if 3 1 roll% .. h dx dy

			% Draw bow arc
			2 copy dEaw mul exch dEaw mul exch% .. h x y dx' dy'
			3 index 2 div 3 index 2 div			% .. h x y dx' dy' xm ym 
			6 index add

			0 0 3 index 6 index sub				% .. h x y dx' dy' xm ym 0 0 xm'
			3 index 6 index sub					% .. h x y dx' dy' xm ym 0 0 xm' ym'
			5 index 5 index 					% .. h x y dx' dy' xm ym 0 0 xm' ym' xm ym
			rcurveto							% .. h x y dx' dy' xm ym
			6 index 2 mul sub					% .. h x y dx' dy' xm ym''
			2 copy								% .. h x y dx' dy' xm ym'' xm ym''
			rcurveto							% .. h x y 
			pop pop pop
		} {
			moveto lineto
		} ifelse

		% Stroke
		stroke
		pop pop
		grestore
	} ifelse 
} def

% sort_edges: - => -
/sort_edges {
	% Sort edges, ordered by minimal word
	edges {									% edge1 edge2 
		2 copy								% edge1 edge2 edge1 edge2
		0 get exch 0 get exch intcmp dup	% edge1 edge2 cmp cmp
		0 ne {								% edge1 edge2 cmp
			3 1 roll pop pop				% cmp
		} {									% edge1 edge2 cmp
			pop 							% edge1 edge2
			1 get abs exch 1 get abs exch	% wmax1 wmax2
			intcmp							% cmp2
		} ifelse
	} qsort pop

	% Sort edges, ordered by maximal word
	/maxedges edges edges length array copy def
	maxedges {
		2 copy
		1 get abs exch 1 get abs exch intcmp dup
		0 ne {
			3 1 roll pop pop
		} {
			pop 
			0 get exch 0 get exch
			intcmp
		} ifelse
	} qsort pop
} def

% Compute which edges must have a centered label (ie, when the edge's
% in-node has more than one in-coming edge at the bottom/top
% respectively)
/center_edge_label {
	% Create arrays that encode the number of in-coming top/bottom
	% edges for each node
	words length array 				% tin
	words length array 				% tin bin
	0 1 words length 1 sub {		% tin bin i
		dup 3 index exch 0			% tin bin i tin i 0 
		put							% tin bin i
		1 index exch 0				% tin bin bin i 0
		put							% tin bin
	} for							% tin bin

	% Set edge font
	smallfont setfontsize setupfont

	% Record each edge in tin and bin
	edges {							% tin bin edge
		% Record number of incoming edges for each node at top and bottom
		dup 4 1 roll				% edge tin bin edge
		edgein						% ..tin bin in top?
		%1 index 5 1 roll			% ..tin bin in top?  %%%SUPERFLUOUS?!!
		{	dup 3 index exch get	% ..tin bin in count
			1 add					% ..tin bin in count+1
			3 index 3 1 roll put	% ..tin bin
		} {							% ..tin bin in
			dup 2 index exch get	% ..tin bin in count
			4 index length 10 lt 
			{1 add} if				% ..tin bin in count+1
			2 index 3 1 roll put	% ..tin bin
		} ifelse					% ..tin bin
		3 -1 roll pop
	} forall						% tin bin

	% Update each edge according to tin and bin
	edges {							% tin bin edge
		dup edgein 					% tin bin edge in top? 
		{							% tin bin edge in
			3 index exch get 1 gt {	% tin bin edge 
				dup 7 true put
			} if
		} {
			2 index exch get 1 gt {
				dup 7 true put
			} if
		} ifelse					% tin bin edge
		pop	
	} forall						% tin bin

	% Record edge label widths in widths
	edges {							% tin bin edge
		dup edgein pop 				% tin bin edge in
		1 index 7 get not {			% tin bin edge in
			exch dup 2 get			% tin bin in edge lbl
			exch 5 get {stringwidth} 0 format
			pop						% tin bin in w
			widths dup 3 index get	% tin bin in w widths wmax
			3 -1 roll max			% tin bin in widths wmax'
			exch 3 1 roll put		% tin bin
		} {
			pop pop					% tin bin
		} ifelse
	} forall

	% Clean up stack
	pop pop

	% Compute string widths
	/X 0 def
	widths words
	0 1 words length 1 sub {		% widths words i
		dup 3 index exch get		% widths words i wl
		exch 2 index exch get		% widths words wl word
		dup 0 get					% widths words wl word w
		3 -1 roll max				% widths words word wmax

		1 index						% widths words word wmax word
		0 X put						% widths words word wmax

		exch 2 get					% widths words wmax format
		{fontsize} 0 format			% widths words wmax fontsize
		dWr mul /dWline xdef 
		%exch pop					% widths words wmax
		X add dWline add /X exch def	% widths words word
	} for
	/X X dWline sub def

	% Clean up stack
	pop pop
} def

/edgein % edge => in-node top? 
{	% Find in-node
	dup 1 get dup 0 lt {			% edge +/- wmax
		abs 
	} {
		pop dup 0 get	
	} ifelse						% edge in

	% Find top/bottom
	exch 4 get 0 gt
} def 

% Layout words
/layout_arcs {
	% 1. Sort edges according to minimum and maximum word
	sort_edges 

	% 2. Compute edge label centering and word widths
	center_edge_label

	% 3. Compute edge heights for top and bottom edges
	{   } edge_heights
	{neg} edge_heights

	% 4. Compute edge displacements for top and bottom edges
	0 1 edges length 1 sub {
		edges exch get 4 0 put
	} for
	edge_displace

	% 5. compute /lines array 
	split_lines
} def

% print_line: iline => -
/layout_line {
	% Compute line height
	dup lines exch get 						% l L
	dup line_height							% l L height

	% Compute x0, y0, width and height
	1 index 2 get							% l L h x0
	dup 4 index 1 add lines exch get 2 get	% l L h x0 x0 x1
	exch sub 3 1 roll llx exch sub			% l L w h dx
	3 index 3 get ury exch sub				% l L w h dx y0
	4 2 roll pop pop						% l L dx y0

	% Layout word L[l].w0 to L[l+1].w0-1
	2 index 0 get 1							% l L dx y0 w0 1
	5 index 1 add lines exch get 0 get 1 sub% l L dx y0 w0 1 w1-1
	{										% l L dx y0 w
		layout_word pop pop pop				% l L dx y0
	} for
	pop pop pop pop
} def

/print_line {								% l
	% Compute line height
	dup lines exch get 						% l L
	dup line_height							% l L height

	% Compute x0, y0, width and height
	1 index 2 get							% l L h x0
	dup 4 index 1 add lines exch get 2 get	% l L h x0 x0 x1
	exch sub 3 1 roll llx exch sub			% l L w h dx
	3 index 3 get ury exch sub				% l L w h dx y0
	
	% NOTE: abstract coordinates are translated (x,y) => (x+dx, y0-y)

	% Setup clipping path
	gsave 
	
	newpath llx 1 index dL add Emaxht dEA mul add moveto 3 index clipdx2 add 0 rlineto
	0 3 index dL add Emaxht Emaxhb add dEA mul add neg rlineto 3 index clipdx2 add neg 0 rlineto 
	closepath 
	bggray 0 lt not {
		gsave bggray setgray fill grestore
	} if
	clip									% l L w h dx y0
	framegray 0 lt not {
		gsave framegray setgray stroke grestore 
	} if
	newpath
	4 2 roll pop pop						% l L dx y0

	% Draw word L[l].w0 to L[l+1].w0-1
	textfont setfontsize setupfont
	2 index 0 get 1							% l L dx y0 w0 1
	5 index 1 add lines exch get 0 get 1 sub% l L dx y0 w0 1 w1-1
	{										% l L dx y0 w
		print_word							% l L dx y0
	} for

	% Draw edges in L[l-1].cross
	smallfont setfontsize setupfont
	3 index 0 eq {
		[]									% l L dx y0 cross
	} {
		3 index 1 sub lines exch get 6 get	% l L dx y0 cross
	} ifelse
	{	print_edge_cross						% l L dx y0
	} forall

	% Draw edge L[l-1].e0 to L[l].e0-1
	3 index 0 eq {
		0									% l L dx y0 e0
	} {
		3 index 1 sub lines exch get 1 get	% l L dx y0 e0
	} ifelse
	1 4 index 1 get 1 sub {					% l L dx y0 e
		print_edge							% l L dx y0
	} for									% l L dx y0

	% Restore clipping path and exit
	grestore
	pop pop pop pop
} def

% print_lines: 
/layout_lines {
	0 1 lines length 2 sub {				% l
		% Print line
		layout_line			% 
	} for
	lines dup length 1 sub get 				% L[last]
	7 lines dup length 2 sub get 7 get	
	put	
	/nword 0 def
} def

/print_lines {
	0 1 lines length 2 sub {				% l
		% Print line
		dup print_line						% l

		% Execute showpage if next line has y = 0 
		1 add lines exch get 3 get 0 eq		% bool
		{	% Draw alignments (quick-and-dirty fix)
			alignments {
				aload pop align
			} forall

			% Show page
			showpage
		} if
	} for
} def

% draw: - => -
/draw {
	currentdict /title known {llx titley moveto title {show} 0 format} if
	layout_arcs
	layout_lines
	print_lines
} def

/min {
	2 copy lt {pop} {exch pop} ifelse
} def

% setup: labels words edges => -
/setup {
	array /edges exch def
	dup array /words exch def
	array /widths exch def
	/nextw 0 def
	/nexte 0 def
	/strings exch def
	/dT dT Emaxht EmaxhtMax min dEA mul add def
	/dB dB Emaxhb EmaxhbMax min dEA mul add def

	% Store (xc,ytop) coordinates for each word
	/xwords words length array def
	/ywords words length array def
	/ypwords words length array def
	/nword 0 def
	/alignments [] def
} def	

% Initialize fonts
true (ptm) /Times-Roman /Times-Bold /Times-Italic /Times-BoldItalic 
createfontfamily setfontfamily 
10 setfontsize 
0 setfontstyle
0 setarrowtype
setupfont

%% Alignments

% align: aligntop alignbot label => -
/align {
	3 1 roll							 % label aligntop alignbot
	% Draw alignbot						
	dup type (arraytype) ne {
		% alignbot is a word index
		xyword moveto
	} {
		% alignbot is an array
		dup dup xmid exch 0 get xyword		% L xmid x[0] y[0]
		dA add exch pop 3 2 roll		% xc yc L
		{									% xc yc i
			xyword moveto					% xc yc xi yi
			2 copy lineto 					% xc yc
		} forall							% xc yc
		moveto								%
	} ifelse								
	currentpoint 3 2 roll					% label xc yc aligntop
	
	% Draw aligntop							% aligntop
	dup type (arraytype) ne {
		% aligntop is a word index
		xyword topadjust lineto
		currentpoint
	} {
		% aligntop is an array
		dup dup xmid exch 0 get xyword		% L xmid x[0] y[0]
		topadjust dA sub exch pop 		% L xc yc
		2 copy lineto 3 2 roll				% xc yc L
		{									% xc yc i
			xyword topadjust moveto					% xc yc xi yi
			2 copy lineto 					% xc yc
		} forall							% xc yc
	} ifelse

	% Stroke
	gsave 
		currentlinewidth 5 mul setlinewidth
		1 setgray
		stroke
	grestore
	stroke

	% Draw label							% label xc yc xc' yc'
	3 -1 roll add 2 div						% label xc xc' ymid
	3 1 roll add 2 div exch					% label xmid ymid
	moveto cshowbgfill
} def

% topadjust: 
/topadjust {strings dH mul sub 4 sub} def 

/fixbotadjust {strings dH mul sub} def

% xyword: word => x y
/xyword {
	dup xwords exch get
	exch ywords exch get
} def

% xmid: wordlist => xmid ymid
/xmid {
	dup 0 get xwords exch get	% L xmin
	exch dup length 1 sub get	% xmin imax
	xwords exch get				% xmin xmax
	add 2 div					% xmid
} def

% formats: dummy formats list
/formats [] def



